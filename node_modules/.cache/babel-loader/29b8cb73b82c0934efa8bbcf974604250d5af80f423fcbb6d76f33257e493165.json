{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode } from '../../utils/is.js';\nimport { forEach, map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'BlockNode';\nvar dependencies = ['ResultSet', 'Node'];\nexport var createBlockNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    ResultSet,\n    Node\n  } = _ref;\n  class BlockNode extends Node {\n    /**\n     * @constructor BlockNode\n     * @extends {Node}\n     * Holds a set with blocks\n     * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks\n     *            An array with blocks, where a block is constructed as an\n     *            Object with properties block, which is a Node, and visible,\n     *            which is a boolean. The property visible is optional and\n     *            is true by default\n     */\n    constructor(blocks) {\n      super();\n      // validate input, copy blocks\n      if (!Array.isArray(blocks)) throw new Error('Array expected');\n      this.blocks = blocks.map(function (block) {\n        var node = block && block.node;\n        var visible = block && block.visible !== undefined ? block.visible : true;\n        if (!isNode(node)) throw new TypeError('Property \"node\" must be a Node');\n        if (typeof visible !== 'boolean') {\n          throw new TypeError('Property \"visible\" must be a boolean');\n        }\n        return {\n          node,\n          visible\n        };\n      });\n    }\n    get type() {\n      return name;\n    }\n    get isBlockNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var evalBlocks = map(this.blocks, function (block) {\n        return {\n          evaluate: block.node._compile(math, argNames),\n          visible: block.visible\n        };\n      });\n      return function evalBlockNodes(scope, args, context) {\n        var results = [];\n        forEach(evalBlocks, function evalBlockNode(block) {\n          var result = block.evaluate(scope, args, context);\n          if (block.visible) {\n            results.push(result);\n          }\n        });\n        return new ResultSet(results);\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child blocks of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      for (var i = 0; i < this.blocks.length; i++) {\n        callback(this.blocks[i].node, 'blocks[' + i + '].node', this);\n      }\n    }\n\n    /**\n     * Create a new BlockNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {BlockNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      var blocks = [];\n      for (var i = 0; i < this.blocks.length; i++) {\n        var block = this.blocks[i];\n        var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));\n        blocks[i] = {\n          node,\n          visible: block.visible\n        };\n      }\n      return new BlockNode(blocks);\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {BlockNode}\n     */\n    clone() {\n      var blocks = this.blocks.map(function (block) {\n        return {\n          node: block.node,\n          visible: block.visible\n        };\n      });\n      return new BlockNode(blocks);\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n    _toString(options) {\n      return this.blocks.map(function (param) {\n        return param.node.toString(options) + (param.visible ? '' : ';');\n      }).join('\\n');\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        blocks: this.blocks\n      };\n    }\n\n    /**\n     * Instantiate an BlockNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"BlockNode\", blocks: [{node: ..., visible: false}, ...]}`,\n     *     where mathjs is optional\n     * @returns {BlockNode}\n     */\n    static fromJSON(json) {\n      return new BlockNode(json.blocks);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n    toHTML(options) {\n      return this.blocks.map(function (param) {\n        return param.node.toHTML(options) + (param.visible ? '' : '<span class=\"math-separator\">;</span>');\n      }).join('<span class=\"math-separator\"><br /></span>');\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      return this.blocks.map(function (param) {\n        return param.node.toTex(options) + (param.visible ? '' : ';');\n      }).join('\\\\;\\\\;\\n');\n    }\n  }\n  _defineProperty(BlockNode, \"name\", name);\n  return BlockNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isNode","forEach","map","factory","name","dependencies","createBlockNode","_ref","ResultSet","Node","BlockNode","constructor","blocks","Array","isArray","Error","block","node","visible","undefined","TypeError","type","isBlockNode","_compile","math","argNames","evalBlocks","evaluate","evalBlockNodes","scope","args","context","results","evalBlockNode","result","push","callback","i","length","_ifNode","clone","_toString","options","param","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isClass"],"sources":["/Users/alexgeldash/Projects/js-easy-windows-calculator/node_modules/mathjs/lib/esm/expression/node/BlockNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode } from '../../utils/is.js';\nimport { forEach, map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'BlockNode';\nvar dependencies = ['ResultSet', 'Node'];\nexport var createBlockNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    ResultSet,\n    Node\n  } = _ref;\n  class BlockNode extends Node {\n    /**\n     * @constructor BlockNode\n     * @extends {Node}\n     * Holds a set with blocks\n     * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks\n     *            An array with blocks, where a block is constructed as an\n     *            Object with properties block, which is a Node, and visible,\n     *            which is a boolean. The property visible is optional and\n     *            is true by default\n     */\n    constructor(blocks) {\n      super();\n      // validate input, copy blocks\n      if (!Array.isArray(blocks)) throw new Error('Array expected');\n      this.blocks = blocks.map(function (block) {\n        var node = block && block.node;\n        var visible = block && block.visible !== undefined ? block.visible : true;\n        if (!isNode(node)) throw new TypeError('Property \"node\" must be a Node');\n        if (typeof visible !== 'boolean') {\n          throw new TypeError('Property \"visible\" must be a boolean');\n        }\n        return {\n          node,\n          visible\n        };\n      });\n    }\n    get type() {\n      return name;\n    }\n    get isBlockNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var evalBlocks = map(this.blocks, function (block) {\n        return {\n          evaluate: block.node._compile(math, argNames),\n          visible: block.visible\n        };\n      });\n      return function evalBlockNodes(scope, args, context) {\n        var results = [];\n        forEach(evalBlocks, function evalBlockNode(block) {\n          var result = block.evaluate(scope, args, context);\n          if (block.visible) {\n            results.push(result);\n          }\n        });\n        return new ResultSet(results);\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child blocks of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      for (var i = 0; i < this.blocks.length; i++) {\n        callback(this.blocks[i].node, 'blocks[' + i + '].node', this);\n      }\n    }\n\n    /**\n     * Create a new BlockNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {BlockNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      var blocks = [];\n      for (var i = 0; i < this.blocks.length; i++) {\n        var block = this.blocks[i];\n        var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));\n        blocks[i] = {\n          node,\n          visible: block.visible\n        };\n      }\n      return new BlockNode(blocks);\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {BlockNode}\n     */\n    clone() {\n      var blocks = this.blocks.map(function (block) {\n        return {\n          node: block.node,\n          visible: block.visible\n        };\n      });\n      return new BlockNode(blocks);\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n    _toString(options) {\n      return this.blocks.map(function (param) {\n        return param.node.toString(options) + (param.visible ? '' : ';');\n      }).join('\\n');\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        blocks: this.blocks\n      };\n    }\n\n    /**\n     * Instantiate an BlockNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"BlockNode\", blocks: [{node: ..., visible: false}, ...]}`,\n     *     where mathjs is optional\n     * @returns {BlockNode}\n     */\n    static fromJSON(json) {\n      return new BlockNode(json.blocks);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n    toHTML(options) {\n      return this.blocks.map(function (param) {\n        return param.node.toHTML(options) + (param.visible ? '' : '<span class=\"math-separator\">;</span>');\n      }).join('<span class=\"math-separator\"><br /></span>');\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      return this.blocks.map(function (param) {\n        return param.node.toTex(options) + (param.visible ? '' : ';');\n      }).join('\\\\;\\\\;\\n');\n    }\n  }\n  _defineProperty(BlockNode, \"name\", name);\n  return BlockNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}