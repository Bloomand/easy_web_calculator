{"ast":null,"code":"import { isMatrix } from '../../utils/is.js';\nimport { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { format } from '../../utils/string.js';\nimport { clone } from '../../utils/object.js';\nvar name = 'pinv';\nvar dependencies = ['typed', 'matrix', 'inv', 'deepEqual', 'equal', 'dotDivide', 'dot', 'ctranspose', 'divideScalar', 'multiply', 'add', 'Complex'];\nexport var createPinv = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    inv,\n    deepEqual,\n    equal,\n    dotDivide,\n    dot,\n    ctranspose,\n    divideScalar,\n    multiply,\n    add,\n    Complex\n  } = _ref;\n  /**\n   * Calculate the Moore–Penrose inverse of a matrix.\n   *\n   * Syntax:\n   *\n   *     math.pinv(x)\n   *\n   * Examples:\n   *\n   *     math.pinv([[1, 2], [3, 4]])          // returns [[-2, 1], [1.5, -0.5]]\n   *     math.pinv([[1, 0], [0, 1], [0, 1]])  // returns [[1, 0, 0], [0, 0.5, 0.5]]\n   *     math.pinv(4)                         // returns 0.25\n   *\n   * See also:\n   *\n   *     inv\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(x) {\n      var size = isMatrix(x) ? x.size() : arraySize(x);\n      switch (size.length) {\n        case 1:\n          // vector\n          if (_isZeros(x)) return ctranspose(x); // null vector\n          if (size[0] === 1) {\n            return inv(x); // invertible matrix\n          } else {\n            return dotDivide(ctranspose(x), dot(x, x));\n          }\n        case 2:\n          // two dimensional array\n          {\n            if (_isZeros(x)) return ctranspose(x); // zero matrixx\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              try {\n                return inv(x); // invertible matrix\n              } catch (err) {\n                if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {\n                  // Expected\n                } else {\n                  throw err;\n                }\n              }\n            }\n            if (isMatrix(x)) {\n              return matrix(_pinv(x.valueOf(), rows, cols), x.storage());\n            } else {\n              // return an Array\n              return _pinv(x, rows, cols);\n            }\n          }\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    },\n    any: function any(x) {\n      // scalar\n      if (equal(x, 0)) return clone(x); // zero\n      return divideScalar(1, x);\n    }\n  });\n\n  /**\n   * Calculate the Moore–Penrose inverse of a matrix\n   * @param {Array[]} mat     A matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns\n   * @return {Array[]} pinv    Pseudoinverse matrix\n   * @private\n   */\n  function _pinv(mat, rows, cols) {\n    var {\n      C,\n      F\n    } = _rankFact(mat, rows, cols); // TODO: Use SVD instead (may improve precision)\n    var Cpinv = multiply(inv(multiply(ctranspose(C), C)), ctranspose(C));\n    var Fpinv = multiply(ctranspose(F), inv(multiply(F, ctranspose(F))));\n    return multiply(Fpinv, Cpinv);\n  }\n\n  /**\n   * Calculate the reduced row echelon form of a matrix\n   *\n   * Modified from https://rosettacode.org/wiki/Reduced_row_echelon_form\n   *\n   * @param {Array[]} mat     A matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns\n   * @return {Array[]}        Reduced row echelon form\n   * @private\n   */\n  function _rref(mat, rows, cols) {\n    var M = clone(mat);\n    var lead = 0;\n    for (var r = 0; r < rows; r++) {\n      if (cols <= lead) {\n        return M;\n      }\n      var i = r;\n      while (_isZero(M[i][lead])) {\n        i++;\n        if (rows === i) {\n          i = r;\n          lead++;\n          if (cols === lead) {\n            return M;\n          }\n        }\n      }\n      [M[i], M[r]] = [M[r], M[i]];\n      var val = M[r][lead];\n      for (var j = 0; j < cols; j++) {\n        M[r][j] = dotDivide(M[r][j], val);\n      }\n      for (var _i = 0; _i < rows; _i++) {\n        if (_i === r) continue;\n        val = M[_i][lead];\n        for (var _j = 0; _j < cols; _j++) {\n          M[_i][_j] = add(M[_i][_j], multiply(-1, multiply(val, M[r][_j])));\n        }\n      }\n      lead++;\n    }\n    return M;\n  }\n\n  /**\n   * Calculate the rank factorization of a matrix\n   *\n   * @param {Array[]} mat                  A matrix (M)\n   * @param {number} rows                  Number of rows\n   * @param {number} cols                  Number of columns\n   * @return {{C: Array, F: Array}}        rank factorization where M = C F\n   * @private\n   */\n  function _rankFact(mat, rows, cols) {\n    var rref = _rref(mat, rows, cols);\n    var C = mat.map((_, i) => _.filter((_, j) => j < rows && !_isZero(dot(rref[j], rref[j]))));\n    var F = rref.filter((_, i) => !_isZero(dot(rref[i], rref[i])));\n    return {\n      C,\n      F\n    };\n  }\n  function _isZero(x) {\n    return equal(add(x, Complex(1, 1)), add(0, Complex(1, 1)));\n  }\n  function _isZeros(arr) {\n    return deepEqual(add(arr, Complex(1, 1)), add(multiply(arr, 0), Complex(1, 1)));\n  }\n});","map":{"version":3,"names":["isMatrix","arraySize","factory","format","clone","name","dependencies","createPinv","_ref","typed","matrix","inv","deepEqual","equal","dotDivide","dot","ctranspose","divideScalar","multiply","add","Complex","ArrayMatrix","x","size","length","_isZeros","rows","cols","err","Error","message","match","_pinv","valueOf","storage","RangeError","any","mat","C","F","_rankFact","Cpinv","Fpinv","_rref","M","lead","r","i","_isZero","val","j","_i","_j","rref","map","_","filter","arr"],"sources":["/Users/alexgeldash/Projects/calculator/node_modules/mathjs/lib/esm/function/matrix/pinv.js"],"sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { format } from '../../utils/string.js';\nimport { clone } from '../../utils/object.js';\nvar name = 'pinv';\nvar dependencies = ['typed', 'matrix', 'inv', 'deepEqual', 'equal', 'dotDivide', 'dot', 'ctranspose', 'divideScalar', 'multiply', 'add', 'Complex'];\nexport var createPinv = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    inv,\n    deepEqual,\n    equal,\n    dotDivide,\n    dot,\n    ctranspose,\n    divideScalar,\n    multiply,\n    add,\n    Complex\n  } = _ref;\n  /**\n   * Calculate the Moore–Penrose inverse of a matrix.\n   *\n   * Syntax:\n   *\n   *     math.pinv(x)\n   *\n   * Examples:\n   *\n   *     math.pinv([[1, 2], [3, 4]])          // returns [[-2, 1], [1.5, -0.5]]\n   *     math.pinv([[1, 0], [0, 1], [0, 1]])  // returns [[1, 0, 0], [0, 0.5, 0.5]]\n   *     math.pinv(4)                         // returns 0.25\n   *\n   * See also:\n   *\n   *     inv\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(x) {\n      var size = isMatrix(x) ? x.size() : arraySize(x);\n      switch (size.length) {\n        case 1:\n          // vector\n          if (_isZeros(x)) return ctranspose(x); // null vector\n          if (size[0] === 1) {\n            return inv(x); // invertible matrix\n          } else {\n            return dotDivide(ctranspose(x), dot(x, x));\n          }\n        case 2:\n          // two dimensional array\n          {\n            if (_isZeros(x)) return ctranspose(x); // zero matrixx\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              try {\n                return inv(x); // invertible matrix\n              } catch (err) {\n                if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {\n                  // Expected\n                } else {\n                  throw err;\n                }\n              }\n            }\n            if (isMatrix(x)) {\n              return matrix(_pinv(x.valueOf(), rows, cols), x.storage());\n            } else {\n              // return an Array\n              return _pinv(x, rows, cols);\n            }\n          }\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    },\n    any: function any(x) {\n      // scalar\n      if (equal(x, 0)) return clone(x); // zero\n      return divideScalar(1, x);\n    }\n  });\n\n  /**\n   * Calculate the Moore–Penrose inverse of a matrix\n   * @param {Array[]} mat     A matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns\n   * @return {Array[]} pinv    Pseudoinverse matrix\n   * @private\n   */\n  function _pinv(mat, rows, cols) {\n    var {\n      C,\n      F\n    } = _rankFact(mat, rows, cols); // TODO: Use SVD instead (may improve precision)\n    var Cpinv = multiply(inv(multiply(ctranspose(C), C)), ctranspose(C));\n    var Fpinv = multiply(ctranspose(F), inv(multiply(F, ctranspose(F))));\n    return multiply(Fpinv, Cpinv);\n  }\n\n  /**\n   * Calculate the reduced row echelon form of a matrix\n   *\n   * Modified from https://rosettacode.org/wiki/Reduced_row_echelon_form\n   *\n   * @param {Array[]} mat     A matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns\n   * @return {Array[]}        Reduced row echelon form\n   * @private\n   */\n  function _rref(mat, rows, cols) {\n    var M = clone(mat);\n    var lead = 0;\n    for (var r = 0; r < rows; r++) {\n      if (cols <= lead) {\n        return M;\n      }\n      var i = r;\n      while (_isZero(M[i][lead])) {\n        i++;\n        if (rows === i) {\n          i = r;\n          lead++;\n          if (cols === lead) {\n            return M;\n          }\n        }\n      }\n      [M[i], M[r]] = [M[r], M[i]];\n      var val = M[r][lead];\n      for (var j = 0; j < cols; j++) {\n        M[r][j] = dotDivide(M[r][j], val);\n      }\n      for (var _i = 0; _i < rows; _i++) {\n        if (_i === r) continue;\n        val = M[_i][lead];\n        for (var _j = 0; _j < cols; _j++) {\n          M[_i][_j] = add(M[_i][_j], multiply(-1, multiply(val, M[r][_j])));\n        }\n      }\n      lead++;\n    }\n    return M;\n  }\n\n  /**\n   * Calculate the rank factorization of a matrix\n   *\n   * @param {Array[]} mat                  A matrix (M)\n   * @param {number} rows                  Number of rows\n   * @param {number} cols                  Number of columns\n   * @return {{C: Array, F: Array}}        rank factorization where M = C F\n   * @private\n   */\n  function _rankFact(mat, rows, cols) {\n    var rref = _rref(mat, rows, cols);\n    var C = mat.map((_, i) => _.filter((_, j) => j < rows && !_isZero(dot(rref[j], rref[j]))));\n    var F = rref.filter((_, i) => !_isZero(dot(rref[i], rref[i])));\n    return {\n      C,\n      F\n    };\n  }\n  function _isZero(x) {\n    return equal(add(x, Complex(1, 1)), add(0, Complex(1, 1)));\n  }\n  function _isZeros(arr) {\n    return deepEqual(add(arr, Complex(1, 1)), add(multiply(arr, 0), Complex(1, 1)));\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}