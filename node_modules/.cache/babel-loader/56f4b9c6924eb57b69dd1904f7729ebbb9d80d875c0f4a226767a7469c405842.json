{"ast":null,"code":"import { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'divideScalar', 'isZero', 'unaryMinus'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtract,\n    multiply,\n    divideScalar,\n    isZero,\n    unaryMinus\n  } = _ref;\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          }\n          if (size[0] === 0) {\n            return 1; // det of an empty matrix is per definition 1\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n        case 2:\n          {\n            // two-dimensional array\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            }\n            if (cols === 0) {\n              return 1; // det of an empty matrix is per definition 1\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Bareiss algorithm\n      // this algorithm have same complexity as LUP decomposition (O(n^3))\n      // but it preserve precision of floating point more relative to the LUP decomposition\n      var negated = false;\n      var rowIndices = new Array(rows).fill(0).map((_, i) => i); // matrix index of row i\n      for (var k = 0; k < rows; k++) {\n        var k_ = rowIndices[k];\n        if (isZero(matrix[k_][k])) {\n          var _k = void 0;\n          for (_k = k + 1; _k < rows; _k++) {\n            if (!isZero(matrix[rowIndices[_k]][k])) {\n              k_ = rowIndices[_k];\n              rowIndices[_k] = rowIndices[k];\n              rowIndices[k] = k_;\n              negated = !negated;\n              break;\n            }\n          }\n          if (_k === rows) return matrix[k_][k]; // some zero of the type\n        }\n\n        var piv = matrix[k_][k];\n        var piv_ = k === 0 ? 1 : matrix[rowIndices[k - 1]][k - 1];\n        for (var i = k + 1; i < rows; i++) {\n          var i_ = rowIndices[i];\n          for (var j = k + 1; j < rows; j++) {\n            matrix[i_][j] = divideScalar(subtract(multiply(matrix[i_][j], piv), multiply(matrix[i_][k], matrix[k_][j])), piv_);\n          }\n        }\n      }\n      var det = matrix[rowIndices[rows - 1]][rows - 1];\n      return negated ? unaryMinus(det) : det;\n    }\n  }\n});","map":{"version":3,"names":["isMatrix","clone","format","factory","name","dependencies","createDet","_ref","typed","matrix","subtract","multiply","divideScalar","isZero","unaryMinus","any","x","det","size","Array","isArray","length","valueOf","RangeError","rows","cols","_det","negated","rowIndices","fill","map","_","i","k","k_","_k","piv","piv_","i_","j"],"sources":["/Users/alexgeldash/Projects/js-easy-windows-calculator/node_modules/mathjs/lib/esm/function/matrix/det.js"],"sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'divideScalar', 'isZero', 'unaryMinus'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtract,\n    multiply,\n    divideScalar,\n    isZero,\n    unaryMinus\n  } = _ref;\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          }\n          if (size[0] === 0) {\n            return 1; // det of an empty matrix is per definition 1\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n        case 2:\n          {\n            // two-dimensional array\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            }\n            if (cols === 0) {\n              return 1; // det of an empty matrix is per definition 1\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Bareiss algorithm\n      // this algorithm have same complexity as LUP decomposition (O(n^3))\n      // but it preserve precision of floating point more relative to the LUP decomposition\n      var negated = false;\n      var rowIndices = new Array(rows).fill(0).map((_, i) => i); // matrix index of row i\n      for (var k = 0; k < rows; k++) {\n        var k_ = rowIndices[k];\n        if (isZero(matrix[k_][k])) {\n          var _k = void 0;\n          for (_k = k + 1; _k < rows; _k++) {\n            if (!isZero(matrix[rowIndices[_k]][k])) {\n              k_ = rowIndices[_k];\n              rowIndices[_k] = rowIndices[k];\n              rowIndices[k] = k_;\n              negated = !negated;\n              break;\n            }\n          }\n          if (_k === rows) return matrix[k_][k]; // some zero of the type\n        }\n\n        var piv = matrix[k_][k];\n        var piv_ = k === 0 ? 1 : matrix[rowIndices[k - 1]][k - 1];\n        for (var i = k + 1; i < rows; i++) {\n          var i_ = rowIndices[i];\n          for (var j = k + 1; j < rows; j++) {\n            matrix[i_][j] = divideScalar(subtract(multiply(matrix[i_][j], piv), multiply(matrix[i_][k], matrix[k_][j])), piv_);\n          }\n        }\n      }\n      var det = matrix[rowIndices[rows - 1]][rows - 1];\n      return negated ? unaryMinus(det) : det;\n    }\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}