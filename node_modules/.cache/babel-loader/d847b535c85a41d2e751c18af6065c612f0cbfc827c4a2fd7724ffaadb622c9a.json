{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'kldivergence';\nvar dependencies = ['typed', 'matrix', 'divide', 'sum', 'multiply', 'map', 'dotDivide', 'log', 'isNumeric'];\nexport var createKldivergence = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divide,\n    sum,\n    multiply,\n    map,\n    dotDivide,\n    log,\n    isNumeric\n  } = _ref;\n  /**\n     * Calculate the Kullback-Leibler (KL) divergence  between two distributions\n     *\n     * Syntax:\n     *\n     *     math.kldivergence(x, y)\n     *\n     * Examples:\n     *\n     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153\n     *\n     *\n     * @param  {Array | Matrix} q    First vector\n     * @param  {Array | Matrix} p    Second vector\n     * @return {number}              Returns distance between q and p\n     */\n  return typed(name, {\n    'Array, Array': function ArrayArray(q, p) {\n      return _kldiv(matrix(q), matrix(p));\n    },\n    'Matrix, Array': function MatrixArray(q, p) {\n      return _kldiv(q, matrix(p));\n    },\n    'Array, Matrix': function ArrayMatrix(q, p) {\n      return _kldiv(matrix(q), p);\n    },\n    'Matrix, Matrix': function MatrixMatrix(q, p) {\n      return _kldiv(q, p);\n    }\n  });\n  function _kldiv(q, p) {\n    var plength = p.size().length;\n    var qlength = q.size().length;\n    if (plength > 1) {\n      throw new Error('first object must be one dimensional');\n    }\n    if (qlength > 1) {\n      throw new Error('second object must be one dimensional');\n    }\n    if (plength !== qlength) {\n      throw new Error('Length of two vectors must be equal');\n    }\n\n    // Before calculation, apply normalization\n    var sumq = sum(q);\n    if (sumq === 0) {\n      throw new Error('Sum of elements in first object must be non zero');\n    }\n    var sump = sum(p);\n    if (sump === 0) {\n      throw new Error('Sum of elements in second object must be non zero');\n    }\n    var qnorm = divide(q, sum(q));\n    var pnorm = divide(p, sum(p));\n    var result = sum(multiply(qnorm, map(dotDivide(qnorm, pnorm), x => log(x))));\n    if (isNumeric(result)) {\n      return result;\n    } else {\n      return Number.NaN;\n    }\n  }\n});","map":{"version":3,"names":["factory","name","dependencies","createKldivergence","_ref","typed","matrix","divide","sum","multiply","map","dotDivide","log","isNumeric","ArrayArray","q","p","_kldiv","MatrixArray","ArrayMatrix","MatrixMatrix","plength","size","length","qlength","Error","sumq","sump","qnorm","pnorm","result","x","Number","NaN"],"sources":["/Users/alexgeldash/Projects/js-easy-windows-calculator/node_modules/mathjs/lib/esm/function/probability/kldivergence.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'kldivergence';\nvar dependencies = ['typed', 'matrix', 'divide', 'sum', 'multiply', 'map', 'dotDivide', 'log', 'isNumeric'];\nexport var createKldivergence = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divide,\n    sum,\n    multiply,\n    map,\n    dotDivide,\n    log,\n    isNumeric\n  } = _ref;\n  /**\n     * Calculate the Kullback-Leibler (KL) divergence  between two distributions\n     *\n     * Syntax:\n     *\n     *     math.kldivergence(x, y)\n     *\n     * Examples:\n     *\n     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153\n     *\n     *\n     * @param  {Array | Matrix} q    First vector\n     * @param  {Array | Matrix} p    Second vector\n     * @return {number}              Returns distance between q and p\n     */\n  return typed(name, {\n    'Array, Array': function ArrayArray(q, p) {\n      return _kldiv(matrix(q), matrix(p));\n    },\n    'Matrix, Array': function MatrixArray(q, p) {\n      return _kldiv(q, matrix(p));\n    },\n    'Array, Matrix': function ArrayMatrix(q, p) {\n      return _kldiv(matrix(q), p);\n    },\n    'Matrix, Matrix': function MatrixMatrix(q, p) {\n      return _kldiv(q, p);\n    }\n  });\n  function _kldiv(q, p) {\n    var plength = p.size().length;\n    var qlength = q.size().length;\n    if (plength > 1) {\n      throw new Error('first object must be one dimensional');\n    }\n    if (qlength > 1) {\n      throw new Error('second object must be one dimensional');\n    }\n    if (plength !== qlength) {\n      throw new Error('Length of two vectors must be equal');\n    }\n\n    // Before calculation, apply normalization\n    var sumq = sum(q);\n    if (sumq === 0) {\n      throw new Error('Sum of elements in first object must be non zero');\n    }\n    var sump = sum(p);\n    if (sump === 0) {\n      throw new Error('Sum of elements in second object must be non zero');\n    }\n    var qnorm = divide(q, sum(q));\n    var pnorm = divide(p, sum(p));\n    var result = sum(multiply(qnorm, map(dotDivide(qnorm, pnorm), x => log(x))));\n    if (isNumeric(result)) {\n      return result;\n    } else {\n      return Number.NaN;\n    }\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}