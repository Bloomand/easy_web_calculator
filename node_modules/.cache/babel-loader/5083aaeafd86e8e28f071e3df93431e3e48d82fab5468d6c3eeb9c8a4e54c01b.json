{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @param {string} implicit\n   * @return {Object} parentheses\n   * @private\n   */\n  function calculateNecessaryParentheses(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  class RangeNode extends Node {\n    /**\n     * @constructor RangeNode\n     * @extends {Node}\n     * create a range\n     * @param {Node} start  included lower-bound\n     * @param {Node} end    included upper-bound\n     * @param {Node} [step] optional step\n     */\n    constructor(start, end, step) {\n      super();\n      // validate inputs\n      if (!isNode(start)) throw new TypeError('Node expected');\n      if (!isNode(end)) throw new TypeError('Node expected');\n      if (step && !isNode(step)) throw new TypeError('Node expected');\n      if (arguments.length > 3) throw new Error('Too many arguments');\n      this.start = start; // included lower-bound\n      this.end = end; // included upper-bound\n      this.step = step || null; // optional step\n    }\n\n    get type() {\n      return name;\n    }\n    get isRangeNode() {\n      return true;\n    }\n\n    /**\n     * Check whether the RangeNode needs the `end` symbol to be defined.\n     * This end is the size of the Matrix in current dimension.\n     * @return {boolean}\n     */\n    needsEnd() {\n      // find all `end` symbols in this RangeNode\n      var endSymbols = this.filter(function (node) {\n        return isSymbolNode(node) && node.name === 'end';\n      });\n      return endSymbols.length > 0;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var range = math.range;\n      var evalStart = this.start._compile(math, argNames);\n      var evalEnd = this.end._compile(math, argNames);\n      if (this.step) {\n        var evalStep = this.step._compile(math, argNames);\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n        };\n      } else {\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n        };\n      }\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      callback(this.start, 'start', this);\n      callback(this.end, 'end', this);\n      if (this.step) {\n        callback(this.step, 'step', this);\n      }\n    }\n\n    /**\n     * Create a new RangeNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {RangeNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {RangeNode}\n     */\n    clone() {\n      return new RangeNode(this.start, this.end, this.step && this.step);\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n\n      // format string as start:step:stop\n      var str;\n      var start = this.start.toString(options);\n      if (parens.start) {\n        start = '(' + start + ')';\n      }\n      str = start;\n      if (this.step) {\n        var step = this.step.toString(options);\n        if (parens.step) {\n          step = '(' + step + ')';\n        }\n        str += ':' + step;\n      }\n      var end = this.end.toString(options);\n      if (parens.end) {\n        end = '(' + end + ')';\n      }\n      str += ':' + end;\n      return str;\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        start: this.start,\n        end: this.end,\n        step: this.step\n      };\n    }\n\n    /**\n     * Instantiate an RangeNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n     *     where mathjs is optional\n     * @returns {RangeNode}\n     */\n    static fromJSON(json) {\n      return new RangeNode(json.start, json.end, json.step);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n\n      // format string as start:step:stop\n      var str;\n      var start = this.start.toHTML(options);\n      if (parens.start) {\n        start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      str = start;\n      if (this.step) {\n        var step = this.step.toHTML(options);\n        if (parens.step) {\n          step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n      }\n      var end = this.end.toHTML(options);\n      if (parens.end) {\n        end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n      return str;\n    }\n\n    /**\n     * Get LaTeX representation\n     * @params {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n      var str = this.start.toTex(options);\n      if (parens.start) {\n        str = \"\\\\left(\".concat(str, \"\\\\right)\");\n      }\n      if (this.step) {\n        var step = this.step.toTex(options);\n        if (parens.step) {\n          step = \"\\\\left(\".concat(step, \"\\\\right)\");\n        }\n        str += ':' + step;\n      }\n      var end = this.end.toTex(options);\n      if (parens.end) {\n        end = \"\\\\left(\".concat(end, \"\\\\right)\");\n      }\n      str += ':' + end;\n      return str;\n    }\n  }\n  _defineProperty(RangeNode, \"name\", name);\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isNode","isSymbolNode","factory","getPrecedence","name","dependencies","createRangeNode","_ref","Node","calculateNecessaryParentheses","node","parenthesis","implicit","precedence","parens","startPrecedence","start","step","stepPrecedence","endPrecedence","end","RangeNode","constructor","TypeError","arguments","length","Error","type","isRangeNode","needsEnd","endSymbols","filter","_compile","math","argNames","range","evalStart","evalEnd","evalStep","evalRangeNode","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","str","toString","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","isClass"],"sources":["/Users/alexgeldash/Projects/calculator/node_modules/mathjs/lib/esm/expression/node/RangeNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @param {string} implicit\n   * @return {Object} parentheses\n   * @private\n   */\n  function calculateNecessaryParentheses(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  class RangeNode extends Node {\n    /**\n     * @constructor RangeNode\n     * @extends {Node}\n     * create a range\n     * @param {Node} start  included lower-bound\n     * @param {Node} end    included upper-bound\n     * @param {Node} [step] optional step\n     */\n    constructor(start, end, step) {\n      super();\n      // validate inputs\n      if (!isNode(start)) throw new TypeError('Node expected');\n      if (!isNode(end)) throw new TypeError('Node expected');\n      if (step && !isNode(step)) throw new TypeError('Node expected');\n      if (arguments.length > 3) throw new Error('Too many arguments');\n      this.start = start; // included lower-bound\n      this.end = end; // included upper-bound\n      this.step = step || null; // optional step\n    }\n\n    get type() {\n      return name;\n    }\n    get isRangeNode() {\n      return true;\n    }\n\n    /**\n     * Check whether the RangeNode needs the `end` symbol to be defined.\n     * This end is the size of the Matrix in current dimension.\n     * @return {boolean}\n     */\n    needsEnd() {\n      // find all `end` symbols in this RangeNode\n      var endSymbols = this.filter(function (node) {\n        return isSymbolNode(node) && node.name === 'end';\n      });\n      return endSymbols.length > 0;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var range = math.range;\n      var evalStart = this.start._compile(math, argNames);\n      var evalEnd = this.end._compile(math, argNames);\n      if (this.step) {\n        var evalStep = this.step._compile(math, argNames);\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n        };\n      } else {\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n        };\n      }\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      callback(this.start, 'start', this);\n      callback(this.end, 'end', this);\n      if (this.step) {\n        callback(this.step, 'step', this);\n      }\n    }\n\n    /**\n     * Create a new RangeNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {RangeNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {RangeNode}\n     */\n    clone() {\n      return new RangeNode(this.start, this.end, this.step && this.step);\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n\n      // format string as start:step:stop\n      var str;\n      var start = this.start.toString(options);\n      if (parens.start) {\n        start = '(' + start + ')';\n      }\n      str = start;\n      if (this.step) {\n        var step = this.step.toString(options);\n        if (parens.step) {\n          step = '(' + step + ')';\n        }\n        str += ':' + step;\n      }\n      var end = this.end.toString(options);\n      if (parens.end) {\n        end = '(' + end + ')';\n      }\n      str += ':' + end;\n      return str;\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        start: this.start,\n        end: this.end,\n        step: this.step\n      };\n    }\n\n    /**\n     * Instantiate an RangeNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n     *     where mathjs is optional\n     * @returns {RangeNode}\n     */\n    static fromJSON(json) {\n      return new RangeNode(json.start, json.end, json.step);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n\n      // format string as start:step:stop\n      var str;\n      var start = this.start.toHTML(options);\n      if (parens.start) {\n        start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      str = start;\n      if (this.step) {\n        var step = this.step.toHTML(options);\n        if (parens.step) {\n          step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n      }\n      var end = this.end.toHTML(options);\n      if (parens.end) {\n        end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n      return str;\n    }\n\n    /**\n     * Get LaTeX representation\n     * @params {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n      var str = this.start.toTex(options);\n      if (parens.start) {\n        str = \"\\\\left(\".concat(str, \"\\\\right)\");\n      }\n      if (this.step) {\n        var step = this.step.toTex(options);\n        if (parens.step) {\n          step = \"\\\\left(\".concat(step, \"\\\\right)\");\n        }\n        str += ':' + step;\n      }\n      var end = this.end.toTex(options);\n      if (parens.end) {\n        end = \"\\\\left(\".concat(end, \"\\\\right)\");\n      }\n      str += ':' + end;\n      return str;\n    }\n  }\n  _defineProperty(RangeNode, \"name\", name);\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"AAAA,OAAOA,eAAe,MAAM,uCAAuC;AACnE,SAASC,MAAM,EAAEC,YAAY,QAAQ,mBAAmB;AACxD,SAASC,OAAO,QAAQ,wBAAwB;AAChD,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,IAAIC,IAAI,GAAG,WAAW;AACtB,IAAIC,YAAY,GAAG,CAAC,MAAM,CAAC;AAC3B,OAAO,IAAIC,eAAe,GAAG,eAAeJ,OAAO,CAACE,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EAC9E,IAAI;IACFC;EACF,CAAC,GAAGD,IAAI;EACR;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASE,6BAA6BA,CAACC,IAAI,EAAEC,WAAW,EAAEC,QAAQ,EAAE;IAClE,IAAIC,UAAU,GAAGV,aAAa,CAACO,IAAI,EAAEC,WAAW,EAAEC,QAAQ,CAAC;IAC3D,IAAIE,MAAM,GAAG,CAAC,CAAC;IACf,IAAIC,eAAe,GAAGZ,aAAa,CAACO,IAAI,CAACM,KAAK,EAAEL,WAAW,EAAEC,QAAQ,CAAC;IACtEE,MAAM,CAACE,KAAK,GAAGD,eAAe,KAAK,IAAI,IAAIA,eAAe,IAAIF,UAAU,IAAIF,WAAW,KAAK,KAAK;IACjG,IAAID,IAAI,CAACO,IAAI,EAAE;MACb,IAAIC,cAAc,GAAGf,aAAa,CAACO,IAAI,CAACO,IAAI,EAAEN,WAAW,EAAEC,QAAQ,CAAC;MACpEE,MAAM,CAACG,IAAI,GAAGC,cAAc,KAAK,IAAI,IAAIA,cAAc,IAAIL,UAAU,IAAIF,WAAW,KAAK,KAAK;IAChG;IACA,IAAIQ,aAAa,GAAGhB,aAAa,CAACO,IAAI,CAACU,GAAG,EAAET,WAAW,EAAEC,QAAQ,CAAC;IAClEE,MAAM,CAACM,GAAG,GAAGD,aAAa,KAAK,IAAI,IAAIA,aAAa,IAAIN,UAAU,IAAIF,WAAW,KAAK,KAAK;IAC3F,OAAOG,MAAM;EACf;EACA,MAAMO,SAAS,SAASb,IAAI,CAAC;IAC3B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIc,WAAWA,CAACN,KAAK,EAAEI,GAAG,EAAEH,IAAI,EAAE;MAC5B,KAAK,EAAE;MACP;MACA,IAAI,CAACjB,MAAM,CAACgB,KAAK,CAAC,EAAE,MAAM,IAAIO,SAAS,CAAC,eAAe,CAAC;MACxD,IAAI,CAACvB,MAAM,CAACoB,GAAG,CAAC,EAAE,MAAM,IAAIG,SAAS,CAAC,eAAe,CAAC;MACtD,IAAIN,IAAI,IAAI,CAACjB,MAAM,CAACiB,IAAI,CAAC,EAAE,MAAM,IAAIM,SAAS,CAAC,eAAe,CAAC;MAC/D,IAAIC,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;MAC/D,IAAI,CAACV,KAAK,GAAGA,KAAK,CAAC,CAAC;MACpB,IAAI,CAACI,GAAG,GAAGA,GAAG,CAAC,CAAC;MAChB,IAAI,CAACH,IAAI,GAAGA,IAAI,IAAI,IAAI,CAAC,CAAC;IAC5B;;IAEA,IAAIU,IAAIA,CAAA,EAAG;MACT,OAAOvB,IAAI;IACb;IACA,IAAIwB,WAAWA,CAAA,EAAG;MAChB,OAAO,IAAI;IACb;;IAEA;AACJ;AACA;AACA;AACA;IACIC,QAAQA,CAAA,EAAG;MACT;MACA,IAAIC,UAAU,GAAG,IAAI,CAACC,MAAM,CAAC,UAAUrB,IAAI,EAAE;QAC3C,OAAOT,YAAY,CAACS,IAAI,CAAC,IAAIA,IAAI,CAACN,IAAI,KAAK,KAAK;MAClD,CAAC,CAAC;MACF,OAAO0B,UAAU,CAACL,MAAM,GAAG,CAAC;IAC9B;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIO,QAAQA,CAACC,IAAI,EAAEC,QAAQ,EAAE;MACvB,IAAIC,KAAK,GAAGF,IAAI,CAACE,KAAK;MACtB,IAAIC,SAAS,GAAG,IAAI,CAACpB,KAAK,CAACgB,QAAQ,CAACC,IAAI,EAAEC,QAAQ,CAAC;MACnD,IAAIG,OAAO,GAAG,IAAI,CAACjB,GAAG,CAACY,QAAQ,CAACC,IAAI,EAAEC,QAAQ,CAAC;MAC/C,IAAI,IAAI,CAACjB,IAAI,EAAE;QACb,IAAIqB,QAAQ,GAAG,IAAI,CAACrB,IAAI,CAACe,QAAQ,CAACC,IAAI,EAAEC,QAAQ,CAAC;QACjD,OAAO,SAASK,aAAaA,CAACC,KAAK,EAAEC,IAAI,EAAEC,OAAO,EAAE;UAClD,OAAOP,KAAK,CAACC,SAAS,CAACI,KAAK,EAAEC,IAAI,EAAEC,OAAO,CAAC,EAAEL,OAAO,CAACG,KAAK,EAAEC,IAAI,EAAEC,OAAO,CAAC,EAAEJ,QAAQ,CAACE,KAAK,EAAEC,IAAI,EAAEC,OAAO,CAAC,CAAC;QAC9G,CAAC;MACH,CAAC,MAAM;QACL,OAAO,SAASH,aAAaA,CAACC,KAAK,EAAEC,IAAI,EAAEC,OAAO,EAAE;UAClD,OAAOP,KAAK,CAACC,SAAS,CAACI,KAAK,EAAEC,IAAI,EAAEC,OAAO,CAAC,EAAEL,OAAO,CAACG,KAAK,EAAEC,IAAI,EAAEC,OAAO,CAAC,CAAC;QAC9E,CAAC;MACH;IACF;;IAEA;AACJ;AACA;AACA;IACIC,OAAOA,CAACC,QAAQ,EAAE;MAChBA,QAAQ,CAAC,IAAI,CAAC5B,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC;MACnC4B,QAAQ,CAAC,IAAI,CAACxB,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC;MAC/B,IAAI,IAAI,CAACH,IAAI,EAAE;QACb2B,QAAQ,CAAC,IAAI,CAAC3B,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC;MACnC;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;IACI4B,GAAGA,CAACD,QAAQ,EAAE;MACZ,OAAO,IAAIvB,SAAS,CAAC,IAAI,CAACyB,OAAO,CAACF,QAAQ,CAAC,IAAI,CAAC5B,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC8B,OAAO,CAACF,QAAQ,CAAC,IAAI,CAACxB,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC,EAAE,IAAI,CAACH,IAAI,IAAI,IAAI,CAAC6B,OAAO,CAACF,QAAQ,CAAC,IAAI,CAAC3B,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;IACtL;;IAEA;AACJ;AACA;AACA;IACI8B,KAAKA,CAAA,EAAG;MACN,OAAO,IAAI1B,SAAS,CAAC,IAAI,CAACL,KAAK,EAAE,IAAI,CAACI,GAAG,EAAE,IAAI,CAACH,IAAI,IAAI,IAAI,CAACA,IAAI,CAAC;IACpE;;IAEA;AACJ;AACA;AACA;AACA;IACI+B,SAASA,CAACC,OAAO,EAAE;MACjB,IAAItC,WAAW,GAAGsC,OAAO,IAAIA,OAAO,CAACtC,WAAW,GAAGsC,OAAO,CAACtC,WAAW,GAAG,MAAM;MAC/E,IAAIG,MAAM,GAAGL,6BAA6B,CAAC,IAAI,EAAEE,WAAW,EAAEsC,OAAO,IAAIA,OAAO,CAACrC,QAAQ,CAAC;;MAE1F;MACA,IAAIsC,GAAG;MACP,IAAIlC,KAAK,GAAG,IAAI,CAACA,KAAK,CAACmC,QAAQ,CAACF,OAAO,CAAC;MACxC,IAAInC,MAAM,CAACE,KAAK,EAAE;QAChBA,KAAK,GAAG,GAAG,GAAGA,KAAK,GAAG,GAAG;MAC3B;MACAkC,GAAG,GAAGlC,KAAK;MACX,IAAI,IAAI,CAACC,IAAI,EAAE;QACb,IAAIA,IAAI,GAAG,IAAI,CAACA,IAAI,CAACkC,QAAQ,CAACF,OAAO,CAAC;QACtC,IAAInC,MAAM,CAACG,IAAI,EAAE;UACfA,IAAI,GAAG,GAAG,GAAGA,IAAI,GAAG,GAAG;QACzB;QACAiC,GAAG,IAAI,GAAG,GAAGjC,IAAI;MACnB;MACA,IAAIG,GAAG,GAAG,IAAI,CAACA,GAAG,CAAC+B,QAAQ,CAACF,OAAO,CAAC;MACpC,IAAInC,MAAM,CAACM,GAAG,EAAE;QACdA,GAAG,GAAG,GAAG,GAAGA,GAAG,GAAG,GAAG;MACvB;MACA8B,GAAG,IAAI,GAAG,GAAG9B,GAAG;MAChB,OAAO8B,GAAG;IACZ;;IAEA;AACJ;AACA;AACA;IACIE,MAAMA,CAAA,EAAG;MACP,OAAO;QACLC,MAAM,EAAEjD,IAAI;QACZY,KAAK,EAAE,IAAI,CAACA,KAAK;QACjBI,GAAG,EAAE,IAAI,CAACA,GAAG;QACbH,IAAI,EAAE,IAAI,CAACA;MACb,CAAC;IACH;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACI,OAAOqC,QAAQA,CAACC,IAAI,EAAE;MACpB,OAAO,IAAIlC,SAAS,CAACkC,IAAI,CAACvC,KAAK,EAAEuC,IAAI,CAACnC,GAAG,EAAEmC,IAAI,CAACtC,IAAI,CAAC;IACvD;;IAEA;AACJ;AACA;AACA;AACA;IACIuC,MAAMA,CAACP,OAAO,EAAE;MACd,IAAItC,WAAW,GAAGsC,OAAO,IAAIA,OAAO,CAACtC,WAAW,GAAGsC,OAAO,CAACtC,WAAW,GAAG,MAAM;MAC/E,IAAIG,MAAM,GAAGL,6BAA6B,CAAC,IAAI,EAAEE,WAAW,EAAEsC,OAAO,IAAIA,OAAO,CAACrC,QAAQ,CAAC;;MAE1F;MACA,IAAIsC,GAAG;MACP,IAAIlC,KAAK,GAAG,IAAI,CAACA,KAAK,CAACwC,MAAM,CAACP,OAAO,CAAC;MACtC,IAAInC,MAAM,CAACE,KAAK,EAAE;QAChBA,KAAK,GAAG,gEAAgE,GAAGA,KAAK,GAAG,gEAAgE;MACrJ;MACAkC,GAAG,GAAGlC,KAAK;MACX,IAAI,IAAI,CAACC,IAAI,EAAE;QACb,IAAIA,IAAI,GAAG,IAAI,CAACA,IAAI,CAACuC,MAAM,CAACP,OAAO,CAAC;QACpC,IAAInC,MAAM,CAACG,IAAI,EAAE;UACfA,IAAI,GAAG,gEAAgE,GAAGA,IAAI,GAAG,gEAAgE;QACnJ;QACAiC,GAAG,IAAI,0DAA0D,GAAGjC,IAAI;MAC1E;MACA,IAAIG,GAAG,GAAG,IAAI,CAACA,GAAG,CAACoC,MAAM,CAACP,OAAO,CAAC;MAClC,IAAInC,MAAM,CAACM,GAAG,EAAE;QACdA,GAAG,GAAG,gEAAgE,GAAGA,GAAG,GAAG,gEAAgE;MACjJ;MACA8B,GAAG,IAAI,0DAA0D,GAAG9B,GAAG;MACvE,OAAO8B,GAAG;IACZ;;IAEA;AACJ;AACA;AACA;AACA;IACIO,MAAMA,CAACR,OAAO,EAAE;MACd,IAAItC,WAAW,GAAGsC,OAAO,IAAIA,OAAO,CAACtC,WAAW,GAAGsC,OAAO,CAACtC,WAAW,GAAG,MAAM;MAC/E,IAAIG,MAAM,GAAGL,6BAA6B,CAAC,IAAI,EAAEE,WAAW,EAAEsC,OAAO,IAAIA,OAAO,CAACrC,QAAQ,CAAC;MAC1F,IAAIsC,GAAG,GAAG,IAAI,CAAClC,KAAK,CAAC0C,KAAK,CAACT,OAAO,CAAC;MACnC,IAAInC,MAAM,CAACE,KAAK,EAAE;QAChBkC,GAAG,GAAG,SAAS,CAACS,MAAM,CAACT,GAAG,EAAE,UAAU,CAAC;MACzC;MACA,IAAI,IAAI,CAACjC,IAAI,EAAE;QACb,IAAIA,IAAI,GAAG,IAAI,CAACA,IAAI,CAACyC,KAAK,CAACT,OAAO,CAAC;QACnC,IAAInC,MAAM,CAACG,IAAI,EAAE;UACfA,IAAI,GAAG,SAAS,CAAC0C,MAAM,CAAC1C,IAAI,EAAE,UAAU,CAAC;QAC3C;QACAiC,GAAG,IAAI,GAAG,GAAGjC,IAAI;MACnB;MACA,IAAIG,GAAG,GAAG,IAAI,CAACA,GAAG,CAACsC,KAAK,CAACT,OAAO,CAAC;MACjC,IAAInC,MAAM,CAACM,GAAG,EAAE;QACdA,GAAG,GAAG,SAAS,CAACuC,MAAM,CAACvC,GAAG,EAAE,UAAU,CAAC;MACzC;MACA8B,GAAG,IAAI,GAAG,GAAG9B,GAAG;MAChB,OAAO8B,GAAG;IACZ;EACF;EACAnD,eAAe,CAACsB,SAAS,EAAE,MAAM,EAAEjB,IAAI,CAAC;EACxC,OAAOiB,SAAS;AAClB,CAAC,EAAE;EACDuC,OAAO,EAAE,IAAI;EACb5D,MAAM,EAAE;AACV,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}