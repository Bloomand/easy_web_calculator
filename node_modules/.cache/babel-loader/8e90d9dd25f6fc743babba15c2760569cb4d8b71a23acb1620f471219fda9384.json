{"ast":null,"code":"import { factory } from '../../../utils/factory.js';\nimport { createSolveValidation } from './utils/solveValidation.js';\nvar name = 'lsolveAll';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nexport var createLsolveAll = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divideScalar,\n    multiplyScalar,\n    subtract,\n    equalScalar,\n    DenseMatrix\n  } = _ref;\n  var solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n\n  /**\n   * Finds all solutions of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix.\n   *\n   * `L * x = b`\n   *\n   * Syntax:\n   *\n   *    math.lsolveAll(L, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = lsolveAll(a, b)  // [ [[-5.5], [20]] ]\n   *\n   * See also:\n   *\n   *    lsolve, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system\n   */\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      var m = matrix(a);\n      var R = _denseForwardSubstitution(m, b);\n      return R.map(r => r.valueOf());\n    }\n  });\n  function _denseForwardSubstitution(m, b_) {\n    // the algorithm is derived from\n    // https://www.overleaf.com/read/csvgqdxggyjv\n\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];\n    var M = m._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n\n    // loop columns\n    for (var i = 0; i < columns; i++) {\n      var L = B.length;\n\n      // loop right-hand sides\n      for (var k = 0; k < L; k++) {\n        var b = B[k];\n        if (!equalScalar(M[i][i], 0)) {\n          // non-singular row\n\n          b[i] = divideScalar(b[i], M[i][i]);\n          for (var j = i + 1; j < columns; j++) {\n            // b[j] -= b[i] * M[j,i]\n            b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n\n          var bNew = [...b];\n          bNew[i] = 1;\n          for (var _j = i + 1; _j < columns; _j++) {\n            bNew[_j] = subtract(bNew[_j], M[_j][i]);\n          }\n          B.push(bNew);\n        }\n      }\n    }\n    return B.map(x => new DenseMatrix({\n      data: x.map(e => [e]),\n      size: [rows, 1]\n    }));\n  }\n  function _sparseForwardSubstitution(m, b_) {\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n\n    // loop columns\n    for (var i = 0; i < columns; i++) {\n      var L = B.length;\n\n      // loop right-hand sides\n      for (var k = 0; k < L; k++) {\n        var b = B[k];\n\n        // values & indices (column i)\n        var iValues = [];\n        var iIndices = [];\n\n        // first & last indeces in column\n        var firstIndex = ptr[i];\n        var lastIndex = ptr[i + 1];\n\n        // find the value at [i, i]\n        var Mii = 0;\n        for (var j = firstIndex; j < lastIndex; j++) {\n          var J = index[j];\n          // check row\n          if (J === i) {\n            Mii = values[j];\n          } else if (J > i) {\n            // store lower triangular\n            iValues.push(values[j]);\n            iIndices.push(J);\n          }\n        }\n        if (!equalScalar(Mii, 0)) {\n          // non-singular row\n\n          b[i] = divideScalar(b[i], Mii);\n          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {\n            var _J = iIndices[_j2];\n            b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n\n          var bNew = [...b];\n          bNew[i] = 1;\n          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {\n            var _J2 = iIndices[_j3];\n            bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);\n          }\n          B.push(bNew);\n        }\n      }\n    }\n    return B.map(x => new DenseMatrix({\n      data: x.map(e => [e]),\n      size: [rows, 1]\n    }));\n  }\n});","map":{"version":3,"names":["factory","createSolveValidation","name","dependencies","createLsolveAll","_ref","typed","matrix","divideScalar","multiplyScalar","subtract","equalScalar","DenseMatrix","solveValidation","SparseMatrixArrayMatrix","m","b","_sparseForwardSubstitution","DenseMatrixArrayMatrix","_denseForwardSubstitution","ArrayArrayMatrix","a","R","map","r","valueOf","b_","B","_data","e","M","rows","_size","columns","i","L","length","k","j","splice","bNew","_j","push","x","data","size","values","_values","index","_index","ptr","_ptr","iValues","iIndices","firstIndex","lastIndex","Mii","J","_j2","_lastIndex","_J","_j3","_lastIndex2","_J2"],"sources":["/Users/alexgeldash/Projects/calculator/node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js"],"sourcesContent":["import { factory } from '../../../utils/factory.js';\nimport { createSolveValidation } from './utils/solveValidation.js';\nvar name = 'lsolveAll';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nexport var createLsolveAll = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divideScalar,\n    multiplyScalar,\n    subtract,\n    equalScalar,\n    DenseMatrix\n  } = _ref;\n  var solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n\n  /**\n   * Finds all solutions of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix.\n   *\n   * `L * x = b`\n   *\n   * Syntax:\n   *\n   *    math.lsolveAll(L, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = lsolveAll(a, b)  // [ [[-5.5], [20]] ]\n   *\n   * See also:\n   *\n   *    lsolve, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system\n   */\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      var m = matrix(a);\n      var R = _denseForwardSubstitution(m, b);\n      return R.map(r => r.valueOf());\n    }\n  });\n  function _denseForwardSubstitution(m, b_) {\n    // the algorithm is derived from\n    // https://www.overleaf.com/read/csvgqdxggyjv\n\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];\n    var M = m._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n\n    // loop columns\n    for (var i = 0; i < columns; i++) {\n      var L = B.length;\n\n      // loop right-hand sides\n      for (var k = 0; k < L; k++) {\n        var b = B[k];\n        if (!equalScalar(M[i][i], 0)) {\n          // non-singular row\n\n          b[i] = divideScalar(b[i], M[i][i]);\n          for (var j = i + 1; j < columns; j++) {\n            // b[j] -= b[i] * M[j,i]\n            b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n\n          var bNew = [...b];\n          bNew[i] = 1;\n          for (var _j = i + 1; _j < columns; _j++) {\n            bNew[_j] = subtract(bNew[_j], M[_j][i]);\n          }\n          B.push(bNew);\n        }\n      }\n    }\n    return B.map(x => new DenseMatrix({\n      data: x.map(e => [e]),\n      size: [rows, 1]\n    }));\n  }\n  function _sparseForwardSubstitution(m, b_) {\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n\n    // loop columns\n    for (var i = 0; i < columns; i++) {\n      var L = B.length;\n\n      // loop right-hand sides\n      for (var k = 0; k < L; k++) {\n        var b = B[k];\n\n        // values & indices (column i)\n        var iValues = [];\n        var iIndices = [];\n\n        // first & last indeces in column\n        var firstIndex = ptr[i];\n        var lastIndex = ptr[i + 1];\n\n        // find the value at [i, i]\n        var Mii = 0;\n        for (var j = firstIndex; j < lastIndex; j++) {\n          var J = index[j];\n          // check row\n          if (J === i) {\n            Mii = values[j];\n          } else if (J > i) {\n            // store lower triangular\n            iValues.push(values[j]);\n            iIndices.push(J);\n          }\n        }\n        if (!equalScalar(Mii, 0)) {\n          // non-singular row\n\n          b[i] = divideScalar(b[i], Mii);\n          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {\n            var _J = iIndices[_j2];\n            b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n\n          var bNew = [...b];\n          bNew[i] = 1;\n          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {\n            var _J2 = iIndices[_j3];\n            bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);\n          }\n          B.push(bNew);\n        }\n      }\n    }\n    return B.map(x => new DenseMatrix({\n      data: x.map(e => [e]),\n      size: [rows, 1]\n    }));\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}