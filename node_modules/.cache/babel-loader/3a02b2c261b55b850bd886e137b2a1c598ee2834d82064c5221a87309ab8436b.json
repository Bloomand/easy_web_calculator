{"ast":null,"code":"import { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'transpose';\nvar dependencies = ['typed', 'matrix'];\nexport var createTranspose = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix\n  } = _ref;\n  /**\n   * Transpose a matrix. All values of the matrix are reflected over its\n   * main diagonal. Only applicable to two dimensional matrices containing\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\n   * vectors and scalars return the input unchanged.\n   *\n   * Syntax:\n   *\n   *     math.transpose(x)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\n   *\n   * See also:\n   *\n   *     diag, inv, subset, squeeze\n   *\n   * @param {Array | Matrix} x  Matrix to be transposed\n   * @return {Array | Matrix}   The transposed matrix\n   */\n  return typed(name, {\n    Array: x => transposeMatrix(matrix(x)).valueOf(),\n    Matrix: transposeMatrix,\n    any: clone // scalars\n  });\n\n  function transposeMatrix(x) {\n    // matrix size\n    var size = x.size();\n\n    // result\n    var c;\n\n    // process dimensions\n    switch (size.length) {\n      case 1:\n        // vector\n        c = x.clone();\n        break;\n      case 2:\n        {\n          // rows and columns\n          var rows = size[0];\n          var columns = size[1];\n\n          // check columns\n          if (columns === 0) {\n            // throw exception\n            throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');\n          }\n\n          // process storage format\n          switch (x.storage()) {\n            case 'dense':\n              c = _denseTranspose(x, rows, columns);\n              break;\n            case 'sparse':\n              c = _sparseTranspose(x, rows, columns);\n              break;\n          }\n        }\n        break;\n      default:\n        // multi dimensional\n        throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(size) + ')');\n    }\n    return c;\n  }\n  function _denseTranspose(m, rows, columns) {\n    // matrix array\n    var data = m._data;\n    // transposed matrix data\n    var transposed = [];\n    var transposedRow;\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // initialize row\n      transposedRow = transposed[j] = [];\n      // loop rows\n      for (var i = 0; i < rows; i++) {\n        // set data\n        transposedRow[i] = clone(data[i][j]);\n      }\n    }\n    // return matrix\n    return m.createDenseMatrix({\n      data: transposed,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n  function _sparseTranspose(m, rows, columns) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n    // result matrices\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = [];\n    // row counts\n    var w = [];\n    for (var x = 0; x < rows; x++) {\n      w[x] = 0;\n    }\n    // vars\n    var p, l, j;\n    // loop values in matrix\n    for (p = 0, l = index.length; p < l; p++) {\n      // number of values in row\n      w[index[p]]++;\n    }\n    // cumulative sum\n    var sum = 0;\n    // initialize cptr with the cummulative sum of row counts\n    for (var i = 0; i < rows; i++) {\n      // update cptr\n      cptr.push(sum);\n      // update sum\n      sum += w[i];\n      // update w\n      w[i] = cptr[i];\n    }\n    // update cptr\n    cptr.push(sum);\n    // loop columns\n    for (j = 0; j < columns; j++) {\n      // values & index in column\n      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\n        // C values & index\n        var q = w[index[k]]++;\n        // C[j, i] = A[i, j]\n        cindex[q] = j;\n        // check we need to process values (pattern matrix)\n        if (values) {\n          cvalues[q] = clone(values[k]);\n        }\n      }\n    }\n    // return matrix\n    return m.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n});","map":{"version":3,"names":["clone","format","factory","name","dependencies","createTranspose","_ref","typed","matrix","Array","x","transposeMatrix","valueOf","Matrix","any","size","c","length","rows","columns","RangeError","storage","_denseTranspose","_sparseTranspose","m","data","_data","transposed","transposedRow","j","i","createDenseMatrix","datatype","_datatype","values","_values","index","_index","ptr","_ptr","cvalues","undefined","cindex","cptr","w","p","l","sum","push","k0","k1","k","q","createSparseMatrix"],"sources":["/Users/alexgeldash/Projects/calculator/node_modules/mathjs/lib/esm/function/matrix/transpose.js"],"sourcesContent":["import { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'transpose';\nvar dependencies = ['typed', 'matrix'];\nexport var createTranspose = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix\n  } = _ref;\n  /**\n   * Transpose a matrix. All values of the matrix are reflected over its\n   * main diagonal. Only applicable to two dimensional matrices containing\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\n   * vectors and scalars return the input unchanged.\n   *\n   * Syntax:\n   *\n   *     math.transpose(x)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\n   *\n   * See also:\n   *\n   *     diag, inv, subset, squeeze\n   *\n   * @param {Array | Matrix} x  Matrix to be transposed\n   * @return {Array | Matrix}   The transposed matrix\n   */\n  return typed(name, {\n    Array: x => transposeMatrix(matrix(x)).valueOf(),\n    Matrix: transposeMatrix,\n    any: clone // scalars\n  });\n\n  function transposeMatrix(x) {\n    // matrix size\n    var size = x.size();\n\n    // result\n    var c;\n\n    // process dimensions\n    switch (size.length) {\n      case 1:\n        // vector\n        c = x.clone();\n        break;\n      case 2:\n        {\n          // rows and columns\n          var rows = size[0];\n          var columns = size[1];\n\n          // check columns\n          if (columns === 0) {\n            // throw exception\n            throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');\n          }\n\n          // process storage format\n          switch (x.storage()) {\n            case 'dense':\n              c = _denseTranspose(x, rows, columns);\n              break;\n            case 'sparse':\n              c = _sparseTranspose(x, rows, columns);\n              break;\n          }\n        }\n        break;\n      default:\n        // multi dimensional\n        throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(size) + ')');\n    }\n    return c;\n  }\n  function _denseTranspose(m, rows, columns) {\n    // matrix array\n    var data = m._data;\n    // transposed matrix data\n    var transposed = [];\n    var transposedRow;\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // initialize row\n      transposedRow = transposed[j] = [];\n      // loop rows\n      for (var i = 0; i < rows; i++) {\n        // set data\n        transposedRow[i] = clone(data[i][j]);\n      }\n    }\n    // return matrix\n    return m.createDenseMatrix({\n      data: transposed,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n  function _sparseTranspose(m, rows, columns) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n    // result matrices\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = [];\n    // row counts\n    var w = [];\n    for (var x = 0; x < rows; x++) {\n      w[x] = 0;\n    }\n    // vars\n    var p, l, j;\n    // loop values in matrix\n    for (p = 0, l = index.length; p < l; p++) {\n      // number of values in row\n      w[index[p]]++;\n    }\n    // cumulative sum\n    var sum = 0;\n    // initialize cptr with the cummulative sum of row counts\n    for (var i = 0; i < rows; i++) {\n      // update cptr\n      cptr.push(sum);\n      // update sum\n      sum += w[i];\n      // update w\n      w[i] = cptr[i];\n    }\n    // update cptr\n    cptr.push(sum);\n    // loop columns\n    for (j = 0; j < columns; j++) {\n      // values & index in column\n      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\n        // C values & index\n        var q = w[index[k]]++;\n        // C[j, i] = A[i, j]\n        cindex[q] = j;\n        // check we need to process values (pattern matrix)\n        if (values) {\n          cvalues[q] = clone(values[k]);\n        }\n      }\n    }\n    // return matrix\n    return m.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}