{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'matrixFromFunction';\nvar dependencies = ['typed', 'matrix', 'isZero'];\nexport var createMatrixFromFunction = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    isZero\n  } = _ref;\n  /**\n   * Create a matrix by evaluating a generating function at each index.\n   * The simplest overload returns a multi-dimensional array as long as `size` is an array.\n   * Passing `size` as a Matrix or specifying a `format` will result in returning a Matrix.\n   *\n   * Syntax:\n   *\n   *    math.matrixFromFunction(size, fn)\n   *    math.matrixFromFunction(size, fn, format)\n   *    math.matrixFromFunction(size, fn, format, datatype)\n   *    math.matrixFromFunction(size, format, fn)\n   *    math.matrixFromFunction(size, format, datatype, fn)\n   *\n   * Examples:\n   *\n   *    math.matrixFromFunction([3,3], i => i[0] - i[1]) // an antisymmetric matrix\n   *    math.matrixFromFunction([100, 100], 'sparse', i => i[0] - i[1] === 1 ? 4 : 0) // a sparse subdiagonal matrix\n   *    math.matrixFromFunction([5], i => math.random()) // a random vector\n   *\n   * See also:\n   *\n   *    matrix, zeros\n   *\n   * @param {Array | Matrix} size   The size of the matrix to be created\n   * @param {function} fn           Callback function invoked for every entry in the matrix\n   * @param {string} [format]       The Matrix storage format, either `'dense'` or `'sparse'`\n   * @param {string} [datatype]     Type of the values\n   * @return {Array | Matrix} Returns the created matrix\n   */\n  return typed(name, {\n    'Array | Matrix, function, string, string': function ArrayMatrixFunctionStringString(size, fn, format, datatype) {\n      return _create(size, fn, format, datatype);\n    },\n    'Array | Matrix, function, string': function ArrayMatrixFunctionString(size, fn, format) {\n      return _create(size, fn, format);\n    },\n    'Matrix, function': function MatrixFunction(size, fn) {\n      return _create(size, fn, 'dense');\n    },\n    'Array, function': function ArrayFunction(size, fn) {\n      return _create(size, fn, 'dense').toArray();\n    },\n    'Array | Matrix, string, function': function ArrayMatrixStringFunction(size, format, fn) {\n      return _create(size, fn, format);\n    },\n    'Array | Matrix, string, string, function': function ArrayMatrixStringStringFunction(size, format, datatype, fn) {\n      return _create(size, fn, format, datatype);\n    }\n  });\n  function _create(size, fn, format, datatype) {\n    var m;\n    if (datatype !== undefined) {\n      m = matrix(format, datatype);\n    } else {\n      m = matrix(format);\n    }\n    m.resize(size);\n    m.forEach(function (_, index) {\n      var val = fn(index);\n      if (isZero(val)) return;\n      m.set(index, val);\n    });\n    return m;\n  }\n});","map":{"version":3,"names":["factory","name","dependencies","createMatrixFromFunction","_ref","typed","matrix","isZero","ArrayMatrixFunctionStringString","size","fn","format","datatype","_create","ArrayMatrixFunctionString","MatrixFunction","ArrayFunction","toArray","ArrayMatrixStringFunction","ArrayMatrixStringStringFunction","m","undefined","resize","forEach","_","index","val","set"],"sources":["/Users/alexgeldash/Projects/js-easy-windows-calculator/node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'matrixFromFunction';\nvar dependencies = ['typed', 'matrix', 'isZero'];\nexport var createMatrixFromFunction = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    isZero\n  } = _ref;\n  /**\n   * Create a matrix by evaluating a generating function at each index.\n   * The simplest overload returns a multi-dimensional array as long as `size` is an array.\n   * Passing `size` as a Matrix or specifying a `format` will result in returning a Matrix.\n   *\n   * Syntax:\n   *\n   *    math.matrixFromFunction(size, fn)\n   *    math.matrixFromFunction(size, fn, format)\n   *    math.matrixFromFunction(size, fn, format, datatype)\n   *    math.matrixFromFunction(size, format, fn)\n   *    math.matrixFromFunction(size, format, datatype, fn)\n   *\n   * Examples:\n   *\n   *    math.matrixFromFunction([3,3], i => i[0] - i[1]) // an antisymmetric matrix\n   *    math.matrixFromFunction([100, 100], 'sparse', i => i[0] - i[1] === 1 ? 4 : 0) // a sparse subdiagonal matrix\n   *    math.matrixFromFunction([5], i => math.random()) // a random vector\n   *\n   * See also:\n   *\n   *    matrix, zeros\n   *\n   * @param {Array | Matrix} size   The size of the matrix to be created\n   * @param {function} fn           Callback function invoked for every entry in the matrix\n   * @param {string} [format]       The Matrix storage format, either `'dense'` or `'sparse'`\n   * @param {string} [datatype]     Type of the values\n   * @return {Array | Matrix} Returns the created matrix\n   */\n  return typed(name, {\n    'Array | Matrix, function, string, string': function ArrayMatrixFunctionStringString(size, fn, format, datatype) {\n      return _create(size, fn, format, datatype);\n    },\n    'Array | Matrix, function, string': function ArrayMatrixFunctionString(size, fn, format) {\n      return _create(size, fn, format);\n    },\n    'Matrix, function': function MatrixFunction(size, fn) {\n      return _create(size, fn, 'dense');\n    },\n    'Array, function': function ArrayFunction(size, fn) {\n      return _create(size, fn, 'dense').toArray();\n    },\n    'Array | Matrix, string, function': function ArrayMatrixStringFunction(size, format, fn) {\n      return _create(size, fn, format);\n    },\n    'Array | Matrix, string, string, function': function ArrayMatrixStringStringFunction(size, format, datatype, fn) {\n      return _create(size, fn, format, datatype);\n    }\n  });\n  function _create(size, fn, format, datatype) {\n    var m;\n    if (datatype !== undefined) {\n      m = matrix(format, datatype);\n    } else {\n      m = matrix(format);\n    }\n    m.resize(size);\n    m.forEach(function (_, index) {\n      var val = fn(index);\n      if (isZero(val)) return;\n      m.set(index, val);\n    });\n    return m;\n  }\n});"],"mappings":"AAAA,SAASA,OAAO,QAAQ,wBAAwB;AAChD,IAAIC,IAAI,GAAG,oBAAoB;AAC/B,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,QAAQ,CAAC;AAChD,OAAO,IAAIC,wBAAwB,GAAG,eAAeH,OAAO,CAACC,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EACvF,IAAI;IACFC,KAAK;IACLC,MAAM;IACNC;EACF,CAAC,GAAGH,IAAI;EACR;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,KAAK,CAACJ,IAAI,EAAE;IACjB,0CAA0C,EAAE,SAASO,+BAA+BA,CAACC,IAAI,EAAEC,EAAE,EAAEC,MAAM,EAAEC,QAAQ,EAAE;MAC/G,OAAOC,OAAO,CAACJ,IAAI,EAAEC,EAAE,EAAEC,MAAM,EAAEC,QAAQ,CAAC;IAC5C,CAAC;IACD,kCAAkC,EAAE,SAASE,yBAAyBA,CAACL,IAAI,EAAEC,EAAE,EAAEC,MAAM,EAAE;MACvF,OAAOE,OAAO,CAACJ,IAAI,EAAEC,EAAE,EAAEC,MAAM,CAAC;IAClC,CAAC;IACD,kBAAkB,EAAE,SAASI,cAAcA,CAACN,IAAI,EAAEC,EAAE,EAAE;MACpD,OAAOG,OAAO,CAACJ,IAAI,EAAEC,EAAE,EAAE,OAAO,CAAC;IACnC,CAAC;IACD,iBAAiB,EAAE,SAASM,aAAaA,CAACP,IAAI,EAAEC,EAAE,EAAE;MAClD,OAAOG,OAAO,CAACJ,IAAI,EAAEC,EAAE,EAAE,OAAO,CAAC,CAACO,OAAO,EAAE;IAC7C,CAAC;IACD,kCAAkC,EAAE,SAASC,yBAAyBA,CAACT,IAAI,EAAEE,MAAM,EAAED,EAAE,EAAE;MACvF,OAAOG,OAAO,CAACJ,IAAI,EAAEC,EAAE,EAAEC,MAAM,CAAC;IAClC,CAAC;IACD,0CAA0C,EAAE,SAASQ,+BAA+BA,CAACV,IAAI,EAAEE,MAAM,EAAEC,QAAQ,EAAEF,EAAE,EAAE;MAC/G,OAAOG,OAAO,CAACJ,IAAI,EAAEC,EAAE,EAAEC,MAAM,EAAEC,QAAQ,CAAC;IAC5C;EACF,CAAC,CAAC;EACF,SAASC,OAAOA,CAACJ,IAAI,EAAEC,EAAE,EAAEC,MAAM,EAAEC,QAAQ,EAAE;IAC3C,IAAIQ,CAAC;IACL,IAAIR,QAAQ,KAAKS,SAAS,EAAE;MAC1BD,CAAC,GAAGd,MAAM,CAACK,MAAM,EAAEC,QAAQ,CAAC;IAC9B,CAAC,MAAM;MACLQ,CAAC,GAAGd,MAAM,CAACK,MAAM,CAAC;IACpB;IACAS,CAAC,CAACE,MAAM,CAACb,IAAI,CAAC;IACdW,CAAC,CAACG,OAAO,CAAC,UAAUC,CAAC,EAAEC,KAAK,EAAE;MAC5B,IAAIC,GAAG,GAAGhB,EAAE,CAACe,KAAK,CAAC;MACnB,IAAIlB,MAAM,CAACmB,GAAG,CAAC,EAAE;MACjBN,CAAC,CAACO,GAAG,CAACF,KAAK,EAAEC,GAAG,CAAC;IACnB,CAAC,CAAC;IACF,OAAON,CAAC;EACV;AACF,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}