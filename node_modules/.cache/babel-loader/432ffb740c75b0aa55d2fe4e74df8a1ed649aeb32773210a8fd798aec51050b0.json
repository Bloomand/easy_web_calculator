{"ast":null,"code":"import { containsCollections } from '../../utils/collection.js';\nimport { factory } from '../../utils/factory.js';\nimport { _switch } from '../../utils/switch.js';\nimport { improveErrorMessage } from './utils/improveErrorMessage.js';\nimport { arraySize } from '../../utils/array.js';\nimport { IndexError } from '../../error/IndexError.js';\nvar name = 'cumsum';\nvar dependencies = ['typed', 'add', 'unaryPlus'];\nexport var createCumSum = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    add,\n    unaryPlus\n  } = _ref;\n  /**\n   * Compute the cumulative sum of a matrix or a list with values.\n   * In case of a (multi dimensional) array or matrix, the cumulative sums\n   * along a specified dimension (defaulting to the first) will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.cumsum(a, b, c, ...)\n   *     math.cumsum(A)\n   *\n   * Examples:\n   *\n   *     math.cumsum(2, 1, 4, 3)               // returns [2, 3, 7, 10]\n   *     math.cumsum([2, 1, 4, 3])             // returns [2, 3, 7, 10]\n   *     math.cumsum([[1, 2], [3, 4]])         // returns [[1, 2], [4, 6]]\n   *     math.cumsum([[1, 2], [3, 4]], 0)      // returns [[1, 2], [4, 6]]\n   *     math.cumsum([[1, 2], [3, 4]], 1)      // returns [[1, 3], [3, 7]]\n   *     math.cumsum([[2, 5], [4, 3], [1, 7]]) // returns [[2, 5], [6, 8], [7, 15]]\n   *\n   * See also:\n   *\n   *    mean, median, min, max, prod, std, variance, sum\n   *\n   * @param {... *} args  A single matrix or or multiple scalar values\n   * @return {*} The cumulative sum of all values\n   */\n  return typed(name, {\n    // sum([a, b, c, d, ...])\n    Array: _cumsum,\n    Matrix: function Matrix(matrix) {\n      return matrix.create(_cumsum(matrix.valueOf()));\n    },\n    // sum([a, b, c, d, ...], dim)\n    'Array, number | BigNumber': _ncumSumDim,\n    'Matrix, number | BigNumber': function MatrixNumberBigNumber(matrix, dim) {\n      return matrix.create(_ncumSumDim(matrix.valueOf(), dim));\n    },\n    // cumsum(a, b, c, d, ...)\n    '...': function _(args) {\n      if (containsCollections(args)) {\n        throw new TypeError('All values expected to be scalar in function cumsum');\n      }\n      return _cumsum(args);\n    }\n  });\n\n  /**\n     * Recursively calculate the cumulative sum of an n-dimensional array\n     * @param {Array} array\n     * @return {number} cumsum\n     * @private\n     */\n  function _cumsum(array) {\n    try {\n      return _cumsummap(array);\n    } catch (err) {\n      throw improveErrorMessage(err, name);\n    }\n  }\n  function _cumsummap(array) {\n    if (array.length === 0) {\n      return [];\n    }\n    var sums = [unaryPlus(array[0])]; // unaryPlus converts to number if need be\n    for (var i = 1; i < array.length; ++i) {\n      // Must use add below and not addScalar for the case of summing a\n      // 2+-dimensional array along the 0th dimension (the row vectors,\n      // or higher-d analogues, are literally added to each other).\n      sums.push(add(sums[i - 1], array[i]));\n    }\n    return sums;\n  }\n  function _ncumSumDim(array, dim) {\n    var size = arraySize(array);\n    if (dim < 0 || dim >= size.length) {\n      // TODO: would be more clear when throwing a DimensionError here\n      throw new IndexError(dim, size.length);\n    }\n    try {\n      return _cumsumDimensional(array, dim);\n    } catch (err) {\n      throw improveErrorMessage(err, name);\n    }\n  }\n\n  /* Possible TODO: Refactor _reduce in collection.js to be able to work here as well */\n  function _cumsumDimensional(mat, dim) {\n    var i, ret, tran;\n    if (dim <= 0) {\n      var initialValue = mat[0][0];\n      if (!Array.isArray(initialValue)) {\n        return _cumsummap(mat);\n      } else {\n        tran = _switch(mat);\n        ret = [];\n        for (i = 0; i < tran.length; i++) {\n          ret[i] = _cumsumDimensional(tran[i], dim - 1);\n        }\n        return ret;\n      }\n    } else {\n      ret = [];\n      for (i = 0; i < mat.length; i++) {\n        ret[i] = _cumsumDimensional(mat[i], dim - 1);\n      }\n      return ret;\n    }\n  }\n});","map":{"version":3,"names":["containsCollections","factory","_switch","improveErrorMessage","arraySize","IndexError","name","dependencies","createCumSum","_ref","typed","add","unaryPlus","Array","_cumsum","Matrix","matrix","create","valueOf","_ncumSumDim","MatrixNumberBigNumber","dim","_","args","TypeError","array","_cumsummap","err","length","sums","i","push","size","_cumsumDimensional","mat","ret","tran","initialValue","isArray"],"sources":["/Users/alexgeldash/Projects/calculator/node_modules/mathjs/lib/esm/function/statistics/cumsum.js"],"sourcesContent":["import { containsCollections } from '../../utils/collection.js';\nimport { factory } from '../../utils/factory.js';\nimport { _switch } from '../../utils/switch.js';\nimport { improveErrorMessage } from './utils/improveErrorMessage.js';\nimport { arraySize } from '../../utils/array.js';\nimport { IndexError } from '../../error/IndexError.js';\nvar name = 'cumsum';\nvar dependencies = ['typed', 'add', 'unaryPlus'];\nexport var createCumSum = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    add,\n    unaryPlus\n  } = _ref;\n  /**\n   * Compute the cumulative sum of a matrix or a list with values.\n   * In case of a (multi dimensional) array or matrix, the cumulative sums\n   * along a specified dimension (defaulting to the first) will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.cumsum(a, b, c, ...)\n   *     math.cumsum(A)\n   *\n   * Examples:\n   *\n   *     math.cumsum(2, 1, 4, 3)               // returns [2, 3, 7, 10]\n   *     math.cumsum([2, 1, 4, 3])             // returns [2, 3, 7, 10]\n   *     math.cumsum([[1, 2], [3, 4]])         // returns [[1, 2], [4, 6]]\n   *     math.cumsum([[1, 2], [3, 4]], 0)      // returns [[1, 2], [4, 6]]\n   *     math.cumsum([[1, 2], [3, 4]], 1)      // returns [[1, 3], [3, 7]]\n   *     math.cumsum([[2, 5], [4, 3], [1, 7]]) // returns [[2, 5], [6, 8], [7, 15]]\n   *\n   * See also:\n   *\n   *    mean, median, min, max, prod, std, variance, sum\n   *\n   * @param {... *} args  A single matrix or or multiple scalar values\n   * @return {*} The cumulative sum of all values\n   */\n  return typed(name, {\n    // sum([a, b, c, d, ...])\n    Array: _cumsum,\n    Matrix: function Matrix(matrix) {\n      return matrix.create(_cumsum(matrix.valueOf()));\n    },\n    // sum([a, b, c, d, ...], dim)\n    'Array, number | BigNumber': _ncumSumDim,\n    'Matrix, number | BigNumber': function MatrixNumberBigNumber(matrix, dim) {\n      return matrix.create(_ncumSumDim(matrix.valueOf(), dim));\n    },\n    // cumsum(a, b, c, d, ...)\n    '...': function _(args) {\n      if (containsCollections(args)) {\n        throw new TypeError('All values expected to be scalar in function cumsum');\n      }\n      return _cumsum(args);\n    }\n  });\n\n  /**\n     * Recursively calculate the cumulative sum of an n-dimensional array\n     * @param {Array} array\n     * @return {number} cumsum\n     * @private\n     */\n  function _cumsum(array) {\n    try {\n      return _cumsummap(array);\n    } catch (err) {\n      throw improveErrorMessage(err, name);\n    }\n  }\n  function _cumsummap(array) {\n    if (array.length === 0) {\n      return [];\n    }\n    var sums = [unaryPlus(array[0])]; // unaryPlus converts to number if need be\n    for (var i = 1; i < array.length; ++i) {\n      // Must use add below and not addScalar for the case of summing a\n      // 2+-dimensional array along the 0th dimension (the row vectors,\n      // or higher-d analogues, are literally added to each other).\n      sums.push(add(sums[i - 1], array[i]));\n    }\n    return sums;\n  }\n  function _ncumSumDim(array, dim) {\n    var size = arraySize(array);\n    if (dim < 0 || dim >= size.length) {\n      // TODO: would be more clear when throwing a DimensionError here\n      throw new IndexError(dim, size.length);\n    }\n    try {\n      return _cumsumDimensional(array, dim);\n    } catch (err) {\n      throw improveErrorMessage(err, name);\n    }\n  }\n\n  /* Possible TODO: Refactor _reduce in collection.js to be able to work here as well */\n  function _cumsumDimensional(mat, dim) {\n    var i, ret, tran;\n    if (dim <= 0) {\n      var initialValue = mat[0][0];\n      if (!Array.isArray(initialValue)) {\n        return _cumsummap(mat);\n      } else {\n        tran = _switch(mat);\n        ret = [];\n        for (i = 0; i < tran.length; i++) {\n          ret[i] = _cumsumDimensional(tran[i], dim - 1);\n        }\n        return ret;\n      }\n    } else {\n      ret = [];\n      for (i = 0; i < mat.length; i++) {\n        ret[i] = _cumsumDimensional(mat[i], dim - 1);\n      }\n      return ret;\n    }\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}