{"ast":null,"code":"import { factory } from '../../../utils/factory.js';\nvar name = 'broadcast';\nvar dependancies = ['concat'];\nexport var createBroadcast = /* #__PURE__ */factory(name, dependancies, _ref => {\n  var {\n    concat\n  } = _ref;\n  /**\n  * Broadcasts two matrices, and return both in an array\n  * It checks if it's possible with broadcasting rules\n  *\n  * @param {Matrix}   A      First Matrix\n  * @param {Matrix}   B      Second Matrix\n  *\n  * @return {Matrix[]}      [ broadcastedA, broadcastedB ]\n  */\n  return function (A, B) {\n    var N = Math.max(A._size.length, B._size.length); // max number of dims\n    if (A._size.length === B._size.length) {\n      if (A._size.every((dim, i) => dim === B._size[i])) {\n        // If matrices have the same size return them\n        return [A, B];\n      }\n    }\n    var sizeA = _padLeft(A._size, N, 0); // pad to the left to align dimensions to the right\n    var sizeB = _padLeft(B._size, N, 0); // pad to the left to align dimensions to the right\n\n    // calculate the max dimensions\n    var sizeMax = [];\n    for (var dim = 0; dim < N; dim++) {\n      sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);\n    }\n\n    // check if the broadcasting rules applyes for both matrices\n    for (var _dim = 0; _dim < N; _dim++) {\n      _checkRules(sizeA, sizeMax, _dim);\n      _checkRules(sizeB, sizeMax, _dim);\n    }\n\n    // reshape A or B if needed to make them ready for concat\n    var AA = A.clone();\n    var BB = B.clone();\n    if (AA._size.length < N) {\n      AA.reshape(_padLeft(AA._size, N, 1));\n    } else if (BB._size.length < N) {\n      BB.reshape(_padLeft(BB._size, N, 1));\n    }\n\n    // stretches the matrices on each dimension to make them the same size\n    for (var _dim2 = 0; _dim2 < N; _dim2++) {\n      if (AA._size[_dim2] < sizeMax[_dim2]) {\n        AA = _stretch(AA, sizeMax[_dim2], _dim2);\n      }\n      if (BB._size[_dim2] < sizeMax[_dim2]) {\n        BB = _stretch(BB, sizeMax[_dim2], _dim2);\n      }\n    }\n\n    // return the array with the two broadcasted matrices\n    return [AA, BB];\n  };\n  function _padLeft(shape, N, filler) {\n    // pads an array of dimensions with numbers to the left, unitl the number of dimensions is N\n    return [...Array(N - shape.length).fill(filler), ...shape];\n  }\n  function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {\n    // stretches a matrix up to a certain size in a certain dimension\n    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);\n  }\n  function _checkRules(shape, sizeMax, dim) {\n    if (shape[dim] < sizeMax[dim] & shape[dim] > 1) {\n      throw new Error(\"shape missmatch: missmatch is found in arg with shape (\".concat(shape, \") not possible to broadcast dimension \").concat(dim, \" with size \").concat(shape[dim], \" to size \").concat(sizeMax[dim]));\n    }\n  }\n});","map":{"version":3,"names":["factory","name","dependancies","createBroadcast","_ref","concat","A","B","N","Math","max","_size","length","every","dim","i","sizeA","_padLeft","sizeB","sizeMax","_dim","_checkRules","AA","clone","BB","reshape","_dim2","_stretch","shape","filler","Array","fill","arrayToStretch","sizeToStretch","dimToStretch","Error"],"sources":["/Users/alexgeldash/Projects/calculator/node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js"],"sourcesContent":["import { factory } from '../../../utils/factory.js';\nvar name = 'broadcast';\nvar dependancies = ['concat'];\nexport var createBroadcast = /* #__PURE__ */factory(name, dependancies, _ref => {\n  var {\n    concat\n  } = _ref;\n  /**\n  * Broadcasts two matrices, and return both in an array\n  * It checks if it's possible with broadcasting rules\n  *\n  * @param {Matrix}   A      First Matrix\n  * @param {Matrix}   B      Second Matrix\n  *\n  * @return {Matrix[]}      [ broadcastedA, broadcastedB ]\n  */\n  return function (A, B) {\n    var N = Math.max(A._size.length, B._size.length); // max number of dims\n    if (A._size.length === B._size.length) {\n      if (A._size.every((dim, i) => dim === B._size[i])) {\n        // If matrices have the same size return them\n        return [A, B];\n      }\n    }\n    var sizeA = _padLeft(A._size, N, 0); // pad to the left to align dimensions to the right\n    var sizeB = _padLeft(B._size, N, 0); // pad to the left to align dimensions to the right\n\n    // calculate the max dimensions\n    var sizeMax = [];\n    for (var dim = 0; dim < N; dim++) {\n      sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);\n    }\n\n    // check if the broadcasting rules applyes for both matrices\n    for (var _dim = 0; _dim < N; _dim++) {\n      _checkRules(sizeA, sizeMax, _dim);\n      _checkRules(sizeB, sizeMax, _dim);\n    }\n\n    // reshape A or B if needed to make them ready for concat\n    var AA = A.clone();\n    var BB = B.clone();\n    if (AA._size.length < N) {\n      AA.reshape(_padLeft(AA._size, N, 1));\n    } else if (BB._size.length < N) {\n      BB.reshape(_padLeft(BB._size, N, 1));\n    }\n\n    // stretches the matrices on each dimension to make them the same size\n    for (var _dim2 = 0; _dim2 < N; _dim2++) {\n      if (AA._size[_dim2] < sizeMax[_dim2]) {\n        AA = _stretch(AA, sizeMax[_dim2], _dim2);\n      }\n      if (BB._size[_dim2] < sizeMax[_dim2]) {\n        BB = _stretch(BB, sizeMax[_dim2], _dim2);\n      }\n    }\n\n    // return the array with the two broadcasted matrices\n    return [AA, BB];\n  };\n  function _padLeft(shape, N, filler) {\n    // pads an array of dimensions with numbers to the left, unitl the number of dimensions is N\n    return [...Array(N - shape.length).fill(filler), ...shape];\n  }\n  function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {\n    // stretches a matrix up to a certain size in a certain dimension\n    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);\n  }\n  function _checkRules(shape, sizeMax, dim) {\n    if (shape[dim] < sizeMax[dim] & shape[dim] > 1) {\n      throw new Error(\"shape missmatch: missmatch is found in arg with shape (\".concat(shape, \") not possible to broadcast dimension \").concat(dim, \" with size \").concat(shape[dim], \" to size \").concat(sizeMax[dim]));\n    }\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}