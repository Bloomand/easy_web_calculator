{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n    if (condition) {\n      if (isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n      if (isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n      if (isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\n  }\n  class ConditionalNode extends Node {\n    /**\n     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n     *\n     * @param {Node} condition   Condition, must result in a boolean\n     * @param {Node} trueExpr    Expression evaluated when condition is true\n     * @param {Node} falseExpr   Expression evaluated when condition is true\n     *\n     * @constructor ConditionalNode\n     * @extends {Node}\n     */\n    constructor(condition, trueExpr, falseExpr) {\n      super();\n      if (!isNode(condition)) {\n        throw new TypeError('Parameter condition must be a Node');\n      }\n      if (!isNode(trueExpr)) {\n        throw new TypeError('Parameter trueExpr must be a Node');\n      }\n      if (!isNode(falseExpr)) {\n        throw new TypeError('Parameter falseExpr must be a Node');\n      }\n      this.condition = condition;\n      this.trueExpr = trueExpr;\n      this.falseExpr = falseExpr;\n    }\n    get type() {\n      return name;\n    }\n    get isConditionalNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var evalCondition = this.condition._compile(math, argNames);\n      var evalTrueExpr = this.trueExpr._compile(math, argNames);\n      var evalFalseExpr = this.falseExpr._compile(math, argNames);\n      return function evalConditionalNode(scope, args, context) {\n        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      callback(this.condition, 'condition', this);\n      callback(this.trueExpr, 'trueExpr', this);\n      callback(this.falseExpr, 'falseExpr', this);\n    }\n\n    /**\n     * Create a new ConditionalNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {ConditionalNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {ConditionalNode}\n     */\n    clone() {\n      return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n\n      // Enclose Arguments in parentheses if they are an OperatorNode\n      // or have lower or equal precedence\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\n      // purely based on aesthetics and readability\n      var condition = this.condition.toString(options);\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n        condition = '(' + condition + ')';\n      }\n      var trueExpr = this.trueExpr.toString(options);\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n        trueExpr = '(' + trueExpr + ')';\n      }\n      var falseExpr = this.falseExpr.toString(options);\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n        falseExpr = '(' + falseExpr + ')';\n      }\n      return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        condition: this.condition,\n        trueExpr: this.trueExpr,\n        falseExpr: this.falseExpr\n      };\n    }\n\n    /**\n     * Instantiate an ConditionalNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     ```\n     *     {\"mathjs\": \"ConditionalNode\",\n     *      \"condition\": ...,\n     *      \"trueExpr\": ...,\n     *      \"falseExpr\": ...}\n     *     ```\n     *     where mathjs is optional\n     * @returns {ConditionalNode}\n     */\n    static fromJSON(json) {\n      return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n\n      // Enclose Arguments in parentheses if they are an OperatorNode\n      // or have lower or equal precedence\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\n      // purely based on aesthetics and readability\n      var condition = this.condition.toHTML(options);\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n        condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      var trueExpr = this.trueExpr.toHTML(options);\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n        trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      var falseExpr = this.falseExpr.toHTML(options);\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n        falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n    }\n  }\n  _defineProperty(ConditionalNode, \"name\", name);\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isBigNumber","isComplex","isNode","isUnit","typeOf","factory","getPrecedence","name","dependencies","createConditionalNode","_ref","Node","testCondition","condition","isZero","re","im","value","undefined","TypeError","ConditionalNode","constructor","trueExpr","falseExpr","type","isConditionalNode","_compile","math","argNames","evalCondition","evalTrueExpr","evalFalseExpr","evalConditionalNode","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","parenthesis","precedence","implicit","toString","conditionPrecedence","truePrecedence","falsePrecedence","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isClass"],"sources":["/Users/alexgeldash/Projects/js-easy-windows-calculator/node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n    if (condition) {\n      if (isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n      if (isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n      if (isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\n  }\n  class ConditionalNode extends Node {\n    /**\n     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n     *\n     * @param {Node} condition   Condition, must result in a boolean\n     * @param {Node} trueExpr    Expression evaluated when condition is true\n     * @param {Node} falseExpr   Expression evaluated when condition is true\n     *\n     * @constructor ConditionalNode\n     * @extends {Node}\n     */\n    constructor(condition, trueExpr, falseExpr) {\n      super();\n      if (!isNode(condition)) {\n        throw new TypeError('Parameter condition must be a Node');\n      }\n      if (!isNode(trueExpr)) {\n        throw new TypeError('Parameter trueExpr must be a Node');\n      }\n      if (!isNode(falseExpr)) {\n        throw new TypeError('Parameter falseExpr must be a Node');\n      }\n      this.condition = condition;\n      this.trueExpr = trueExpr;\n      this.falseExpr = falseExpr;\n    }\n    get type() {\n      return name;\n    }\n    get isConditionalNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var evalCondition = this.condition._compile(math, argNames);\n      var evalTrueExpr = this.trueExpr._compile(math, argNames);\n      var evalFalseExpr = this.falseExpr._compile(math, argNames);\n      return function evalConditionalNode(scope, args, context) {\n        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      callback(this.condition, 'condition', this);\n      callback(this.trueExpr, 'trueExpr', this);\n      callback(this.falseExpr, 'falseExpr', this);\n    }\n\n    /**\n     * Create a new ConditionalNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {ConditionalNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {ConditionalNode}\n     */\n    clone() {\n      return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n\n      // Enclose Arguments in parentheses if they are an OperatorNode\n      // or have lower or equal precedence\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\n      // purely based on aesthetics and readability\n      var condition = this.condition.toString(options);\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n        condition = '(' + condition + ')';\n      }\n      var trueExpr = this.trueExpr.toString(options);\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n        trueExpr = '(' + trueExpr + ')';\n      }\n      var falseExpr = this.falseExpr.toString(options);\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n        falseExpr = '(' + falseExpr + ')';\n      }\n      return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        condition: this.condition,\n        trueExpr: this.trueExpr,\n        falseExpr: this.falseExpr\n      };\n    }\n\n    /**\n     * Instantiate an ConditionalNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     ```\n     *     {\"mathjs\": \"ConditionalNode\",\n     *      \"condition\": ...,\n     *      \"trueExpr\": ...,\n     *      \"falseExpr\": ...}\n     *     ```\n     *     where mathjs is optional\n     * @returns {ConditionalNode}\n     */\n    static fromJSON(json) {\n      return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n\n      // Enclose Arguments in parentheses if they are an OperatorNode\n      // or have lower or equal precedence\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\n      // purely based on aesthetics and readability\n      var condition = this.condition.toHTML(options);\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n        condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      var trueExpr = this.trueExpr.toHTML(options);\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n        trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      var falseExpr = this.falseExpr.toHTML(options);\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n        falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n    }\n  }\n  _defineProperty(ConditionalNode, \"name\", name);\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}