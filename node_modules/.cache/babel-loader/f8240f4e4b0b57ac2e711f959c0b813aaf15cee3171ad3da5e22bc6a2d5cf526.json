{"ast":null,"code":"import { isBigNumber } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'rotationMatrix';\nvar dependencies = ['typed', 'config', 'multiplyScalar', 'addScalar', 'unaryMinus', 'norm', 'matrix', 'BigNumber', 'DenseMatrix', 'SparseMatrix', 'cos', 'sin'];\nexport var createRotationMatrix = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    multiplyScalar,\n    addScalar,\n    unaryMinus,\n    norm,\n    BigNumber,\n    matrix,\n    DenseMatrix,\n    SparseMatrix,\n    cos,\n    sin\n  } = _ref;\n  /**\n   * Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians).\n   * Create a 2-dimensional counter-clockwise rotation matrix (3x3) by a given angle (expressed in radians) around a given axis (1x3).\n   *\n   * Syntax:\n   *\n   *    math.rotationMatrix(theta)\n   *    math.rotationMatrix(theta, format)\n   *    math.rotationMatrix(theta, [v])\n   *    math.rotationMatrix(theta, [v], format)\n   *\n   * Examples:\n   *\n   *    math.rotationMatrix(math.pi / 2)                      // returns [[0, -1], [1, 0]]\n   *    math.rotationMatrix(math.bignumber(1))                // returns [[bignumber(cos(1)), bignumber(-sin(1))], [bignumber(sin(1)), bignumber(cos(1))]]\n   *    math.rotationMatrix(math.complex(1 + i))              // returns [[cos(1 + i), -sin(1 + i)], [sin(1 + i), cos(1 + i)]]\n   *    math.rotationMatrix(math.unit('1rad'))                // returns [[cos(1), -sin(1)], [sin(1), cos(1)]]\n   *\n   *    math.rotationMatrix(math.pi / 2, [0, 1, 0])           // returns [[0, 0, 1], [0, 1, 0], [-1, 0, 0]]\n   *    math.rotationMatrix(math.pi / 2, matrix([0, 1, 0]))   // returns matrix([[0, 0, 1], [0, 1, 0], [-1, 0, 0]])\n   *\n   *\n   * See also:\n   *\n   *    matrix, cos, sin\n   *\n   *\n   * @param {number | BigNumber | Complex | Unit} theta    Rotation angle\n   * @param {Array | Matrix} [v]                           Rotation axis\n   * @param {string} [format]                              Result Matrix storage format\n   * @return {Array | Matrix}                              Rotation matrix\n   */\n\n  return typed(name, {\n    '': function _() {\n      return config.matrix === 'Matrix' ? matrix([]) : [];\n    },\n    string: function string(format) {\n      return matrix(format);\n    },\n    'number | BigNumber | Complex | Unit': function numberBigNumberComplexUnit(theta) {\n      return _rotationMatrix2x2(theta, config.matrix === 'Matrix' ? 'dense' : undefined);\n    },\n    'number | BigNumber | Complex | Unit, string': function numberBigNumberComplexUnitString(theta, format) {\n      return _rotationMatrix2x2(theta, format);\n    },\n    'number | BigNumber | Complex | Unit, Array': function numberBigNumberComplexUnitArray(theta, v) {\n      var matrixV = matrix(v);\n      _validateVector(matrixV);\n      return _rotationMatrix3x3(theta, matrixV, undefined);\n    },\n    'number | BigNumber | Complex | Unit, Matrix': function numberBigNumberComplexUnitMatrix(theta, v) {\n      _validateVector(v);\n      var storageType = v.storage() || (config.matrix === 'Matrix' ? 'dense' : undefined);\n      return _rotationMatrix3x3(theta, v, storageType);\n    },\n    'number | BigNumber | Complex | Unit, Array, string': function numberBigNumberComplexUnitArrayString(theta, v, format) {\n      var matrixV = matrix(v);\n      _validateVector(matrixV);\n      return _rotationMatrix3x3(theta, matrixV, format);\n    },\n    'number | BigNumber | Complex | Unit, Matrix, string': function numberBigNumberComplexUnitMatrixString(theta, v, format) {\n      _validateVector(v);\n      return _rotationMatrix3x3(theta, v, format);\n    }\n  });\n\n  /**\n   * Returns 2x2 matrix of 2D rotation of angle theta\n   *\n   * @param {number | BigNumber | Complex | Unit} theta  The rotation angle\n   * @param {string} format                              The result Matrix storage format\n   * @returns {Matrix}\n   * @private\n   */\n  function _rotationMatrix2x2(theta, format) {\n    var Big = isBigNumber(theta);\n    var minusOne = Big ? new BigNumber(-1) : -1;\n    var cosTheta = cos(theta);\n    var sinTheta = sin(theta);\n    var data = [[cosTheta, multiplyScalar(minusOne, sinTheta)], [sinTheta, cosTheta]];\n    return _convertToFormat(data, format);\n  }\n  function _validateVector(v) {\n    var size = v.size();\n    if (size.length < 1 || size[0] !== 3) {\n      throw new RangeError('Vector must be of dimensions 1x3');\n    }\n  }\n  function _mul(array) {\n    return array.reduce((p, curr) => multiplyScalar(p, curr));\n  }\n  function _convertToFormat(data, format) {\n    if (format) {\n      if (format === 'sparse') {\n        return new SparseMatrix(data);\n      }\n      if (format === 'dense') {\n        return new DenseMatrix(data);\n      }\n      throw new TypeError(\"Unknown matrix type \\\"\".concat(format, \"\\\"\"));\n    }\n    return data;\n  }\n\n  /**\n   * Returns a 3x3 matrix of rotation of angle theta around vector v\n   *\n   * @param {number | BigNumber | Complex | Unit} theta The rotation angle\n   * @param {Matrix} v                                  The rotation axis vector\n   * @param {string} format                             The storage format of the resulting matrix\n   * @returns {Matrix}\n   * @private\n   */\n  function _rotationMatrix3x3(theta, v, format) {\n    var normV = norm(v);\n    if (normV === 0) {\n      throw new RangeError('Rotation around zero vector');\n    }\n    var Big = isBigNumber(theta) ? BigNumber : null;\n    var one = Big ? new Big(1) : 1;\n    var minusOne = Big ? new Big(-1) : -1;\n    var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;\n    var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;\n    var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;\n    var c = cos(theta);\n    var oneMinusC = addScalar(one, unaryMinus(c));\n    var s = sin(theta);\n    var r11 = addScalar(c, _mul([vx, vx, oneMinusC]));\n    var r12 = addScalar(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));\n    var r13 = addScalar(_mul([vx, vz, oneMinusC]), _mul([vy, s]));\n    var r21 = addScalar(_mul([vx, vy, oneMinusC]), _mul([vz, s]));\n    var r22 = addScalar(c, _mul([vy, vy, oneMinusC]));\n    var r23 = addScalar(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));\n    var r31 = addScalar(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));\n    var r32 = addScalar(_mul([vy, vz, oneMinusC]), _mul([vx, s]));\n    var r33 = addScalar(c, _mul([vz, vz, oneMinusC]));\n    var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];\n    return _convertToFormat(data, format);\n  }\n});","map":{"version":3,"names":["isBigNumber","factory","name","dependencies","createRotationMatrix","_ref","typed","config","multiplyScalar","addScalar","unaryMinus","norm","BigNumber","matrix","DenseMatrix","SparseMatrix","cos","sin","_","string","format","numberBigNumberComplexUnit","theta","_rotationMatrix2x2","undefined","numberBigNumberComplexUnitString","numberBigNumberComplexUnitArray","v","matrixV","_validateVector","_rotationMatrix3x3","numberBigNumberComplexUnitMatrix","storageType","storage","numberBigNumberComplexUnitArrayString","numberBigNumberComplexUnitMatrixString","Big","minusOne","cosTheta","sinTheta","data","_convertToFormat","size","length","RangeError","_mul","array","reduce","p","curr","TypeError","concat","normV","one","vx","get","vy","vz","c","oneMinusC","s","r11","r12","r13","r21","r22","r23","r31","r32","r33"],"sources":["/Users/alexgeldash/Projects/js-easy-windows-calculator/node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js"],"sourcesContent":["import { isBigNumber } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'rotationMatrix';\nvar dependencies = ['typed', 'config', 'multiplyScalar', 'addScalar', 'unaryMinus', 'norm', 'matrix', 'BigNumber', 'DenseMatrix', 'SparseMatrix', 'cos', 'sin'];\nexport var createRotationMatrix = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    multiplyScalar,\n    addScalar,\n    unaryMinus,\n    norm,\n    BigNumber,\n    matrix,\n    DenseMatrix,\n    SparseMatrix,\n    cos,\n    sin\n  } = _ref;\n  /**\n   * Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians).\n   * Create a 2-dimensional counter-clockwise rotation matrix (3x3) by a given angle (expressed in radians) around a given axis (1x3).\n   *\n   * Syntax:\n   *\n   *    math.rotationMatrix(theta)\n   *    math.rotationMatrix(theta, format)\n   *    math.rotationMatrix(theta, [v])\n   *    math.rotationMatrix(theta, [v], format)\n   *\n   * Examples:\n   *\n   *    math.rotationMatrix(math.pi / 2)                      // returns [[0, -1], [1, 0]]\n   *    math.rotationMatrix(math.bignumber(1))                // returns [[bignumber(cos(1)), bignumber(-sin(1))], [bignumber(sin(1)), bignumber(cos(1))]]\n   *    math.rotationMatrix(math.complex(1 + i))              // returns [[cos(1 + i), -sin(1 + i)], [sin(1 + i), cos(1 + i)]]\n   *    math.rotationMatrix(math.unit('1rad'))                // returns [[cos(1), -sin(1)], [sin(1), cos(1)]]\n   *\n   *    math.rotationMatrix(math.pi / 2, [0, 1, 0])           // returns [[0, 0, 1], [0, 1, 0], [-1, 0, 0]]\n   *    math.rotationMatrix(math.pi / 2, matrix([0, 1, 0]))   // returns matrix([[0, 0, 1], [0, 1, 0], [-1, 0, 0]])\n   *\n   *\n   * See also:\n   *\n   *    matrix, cos, sin\n   *\n   *\n   * @param {number | BigNumber | Complex | Unit} theta    Rotation angle\n   * @param {Array | Matrix} [v]                           Rotation axis\n   * @param {string} [format]                              Result Matrix storage format\n   * @return {Array | Matrix}                              Rotation matrix\n   */\n\n  return typed(name, {\n    '': function _() {\n      return config.matrix === 'Matrix' ? matrix([]) : [];\n    },\n    string: function string(format) {\n      return matrix(format);\n    },\n    'number | BigNumber | Complex | Unit': function numberBigNumberComplexUnit(theta) {\n      return _rotationMatrix2x2(theta, config.matrix === 'Matrix' ? 'dense' : undefined);\n    },\n    'number | BigNumber | Complex | Unit, string': function numberBigNumberComplexUnitString(theta, format) {\n      return _rotationMatrix2x2(theta, format);\n    },\n    'number | BigNumber | Complex | Unit, Array': function numberBigNumberComplexUnitArray(theta, v) {\n      var matrixV = matrix(v);\n      _validateVector(matrixV);\n      return _rotationMatrix3x3(theta, matrixV, undefined);\n    },\n    'number | BigNumber | Complex | Unit, Matrix': function numberBigNumberComplexUnitMatrix(theta, v) {\n      _validateVector(v);\n      var storageType = v.storage() || (config.matrix === 'Matrix' ? 'dense' : undefined);\n      return _rotationMatrix3x3(theta, v, storageType);\n    },\n    'number | BigNumber | Complex | Unit, Array, string': function numberBigNumberComplexUnitArrayString(theta, v, format) {\n      var matrixV = matrix(v);\n      _validateVector(matrixV);\n      return _rotationMatrix3x3(theta, matrixV, format);\n    },\n    'number | BigNumber | Complex | Unit, Matrix, string': function numberBigNumberComplexUnitMatrixString(theta, v, format) {\n      _validateVector(v);\n      return _rotationMatrix3x3(theta, v, format);\n    }\n  });\n\n  /**\n   * Returns 2x2 matrix of 2D rotation of angle theta\n   *\n   * @param {number | BigNumber | Complex | Unit} theta  The rotation angle\n   * @param {string} format                              The result Matrix storage format\n   * @returns {Matrix}\n   * @private\n   */\n  function _rotationMatrix2x2(theta, format) {\n    var Big = isBigNumber(theta);\n    var minusOne = Big ? new BigNumber(-1) : -1;\n    var cosTheta = cos(theta);\n    var sinTheta = sin(theta);\n    var data = [[cosTheta, multiplyScalar(minusOne, sinTheta)], [sinTheta, cosTheta]];\n    return _convertToFormat(data, format);\n  }\n  function _validateVector(v) {\n    var size = v.size();\n    if (size.length < 1 || size[0] !== 3) {\n      throw new RangeError('Vector must be of dimensions 1x3');\n    }\n  }\n  function _mul(array) {\n    return array.reduce((p, curr) => multiplyScalar(p, curr));\n  }\n  function _convertToFormat(data, format) {\n    if (format) {\n      if (format === 'sparse') {\n        return new SparseMatrix(data);\n      }\n      if (format === 'dense') {\n        return new DenseMatrix(data);\n      }\n      throw new TypeError(\"Unknown matrix type \\\"\".concat(format, \"\\\"\"));\n    }\n    return data;\n  }\n\n  /**\n   * Returns a 3x3 matrix of rotation of angle theta around vector v\n   *\n   * @param {number | BigNumber | Complex | Unit} theta The rotation angle\n   * @param {Matrix} v                                  The rotation axis vector\n   * @param {string} format                             The storage format of the resulting matrix\n   * @returns {Matrix}\n   * @private\n   */\n  function _rotationMatrix3x3(theta, v, format) {\n    var normV = norm(v);\n    if (normV === 0) {\n      throw new RangeError('Rotation around zero vector');\n    }\n    var Big = isBigNumber(theta) ? BigNumber : null;\n    var one = Big ? new Big(1) : 1;\n    var minusOne = Big ? new Big(-1) : -1;\n    var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;\n    var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;\n    var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;\n    var c = cos(theta);\n    var oneMinusC = addScalar(one, unaryMinus(c));\n    var s = sin(theta);\n    var r11 = addScalar(c, _mul([vx, vx, oneMinusC]));\n    var r12 = addScalar(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));\n    var r13 = addScalar(_mul([vx, vz, oneMinusC]), _mul([vy, s]));\n    var r21 = addScalar(_mul([vx, vy, oneMinusC]), _mul([vz, s]));\n    var r22 = addScalar(c, _mul([vy, vy, oneMinusC]));\n    var r23 = addScalar(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));\n    var r31 = addScalar(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));\n    var r32 = addScalar(_mul([vy, vz, oneMinusC]), _mul([vx, s]));\n    var r33 = addScalar(c, _mul([vz, vz, oneMinusC]));\n    var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];\n    return _convertToFormat(data, format);\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}