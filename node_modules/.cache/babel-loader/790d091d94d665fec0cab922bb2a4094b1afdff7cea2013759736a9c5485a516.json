{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { getPrecedence } from '../operators.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'RelationalNode';\nvar dependencies = ['Node'];\nexport var createRelationalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  var operatorMap = {\n    equal: '==',\n    unequal: '!=',\n    smaller: '<',\n    larger: '>',\n    smallerEq: '<=',\n    largerEq: '>='\n  };\n  class RelationalNode extends Node {\n    /**\n     * A node representing a chained conditional expression, such as 'x > y > z'\n     *\n     * @param {String[]} conditionals\n     *     An array of conditional operators used to compare the parameters\n     * @param {Node[]} params\n     *     The parameters that will be compared\n     *\n     * @constructor RelationalNode\n     * @extends {Node}\n     */\n    constructor(conditionals, params) {\n      super();\n      if (!Array.isArray(conditionals)) {\n        throw new TypeError('Parameter conditionals must be an array');\n      }\n      if (!Array.isArray(params)) {\n        throw new TypeError('Parameter params must be an array');\n      }\n      if (conditionals.length !== params.length - 1) {\n        throw new TypeError('Parameter params must contain exactly one more element ' + 'than parameter conditionals');\n      }\n      this.conditionals = conditionals;\n      this.params = params;\n    }\n    get type() {\n      return name;\n    }\n    get isRelationalNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var self = this;\n      var compiled = this.params.map(p => p._compile(math, argNames));\n      return function evalRelationalNode(scope, args, context) {\n        var evalLhs;\n        var evalRhs = compiled[0](scope, args, context);\n        for (var i = 0; i < self.conditionals.length; i++) {\n          evalLhs = evalRhs;\n          evalRhs = compiled[i + 1](scope, args, context);\n          var condFn = getSafeProperty(math, self.conditionals[i]);\n          if (!condFn(evalLhs, evalRhs)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      this.params.forEach((n, i) => callback(n, 'params[' + i + ']', this), this);\n    }\n\n    /**\n     * Create a new RelationalNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {RelationalNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      return new RelationalNode(this.conditionals.slice(), this.params.map((n, i) => this._ifNode(callback(n, 'params[' + i + ']', this)), this));\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {RelationalNode}\n     */\n    clone() {\n      return new RelationalNode(this.conditionals, this.params);\n    }\n\n    /**\n     * Get string representation.\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n      var paramStrings = this.params.map(function (p, index) {\n        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);\n        return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n      });\n      var ret = paramStrings[0];\n      for (var i = 0; i < this.conditionals.length; i++) {\n        ret += ' ' + operatorMap[this.conditionals[i]];\n        ret += ' ' + paramStrings[i + 1];\n      }\n      return ret;\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        conditionals: this.conditionals,\n        params: this.params\n      };\n    }\n\n    /**\n     * Instantiate a RelationalNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"RelationalNode\", \"conditionals\": ..., \"params\": ...}`,\n     *     where mathjs is optional\n     * @returns {RelationalNode}\n     */\n    static fromJSON(json) {\n      return new RelationalNode(json.conditionals, json.params);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n      var paramStrings = this.params.map(function (p, index) {\n        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);\n        return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n      });\n      var ret = paramStrings[0];\n      for (var i = 0; i < this.conditionals.length; i++) {\n        ret += '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n      }\n      return ret;\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n      var paramStrings = this.params.map(function (p, index) {\n        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);\n        return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n      });\n      var ret = paramStrings[0];\n      for (var i = 0; i < this.conditionals.length; i++) {\n        ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];\n      }\n      return ret;\n    }\n  }\n  _defineProperty(RelationalNode, \"name\", name);\n  return RelationalNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","getPrecedence","escape","getSafeProperty","latexOperators","factory","name","dependencies","createRelationalNode","_ref","Node","operatorMap","equal","unequal","smaller","larger","smallerEq","largerEq","RelationalNode","constructor","conditionals","params","Array","isArray","TypeError","length","type","isRelationalNode","_compile","math","argNames","self","compiled","map","p","evalRelationalNode","scope","args","context","evalLhs","evalRhs","i","condFn","forEach","callback","n","slice","_ifNode","clone","_toString","options","parenthesis","precedence","implicit","paramStrings","index","paramPrecedence","toString","ret","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isClass","isNode"],"sources":["/Users/alexgeldash/Projects/calculator/node_modules/mathjs/lib/esm/expression/node/RelationalNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { getPrecedence } from '../operators.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'RelationalNode';\nvar dependencies = ['Node'];\nexport var createRelationalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  var operatorMap = {\n    equal: '==',\n    unequal: '!=',\n    smaller: '<',\n    larger: '>',\n    smallerEq: '<=',\n    largerEq: '>='\n  };\n  class RelationalNode extends Node {\n    /**\n     * A node representing a chained conditional expression, such as 'x > y > z'\n     *\n     * @param {String[]} conditionals\n     *     An array of conditional operators used to compare the parameters\n     * @param {Node[]} params\n     *     The parameters that will be compared\n     *\n     * @constructor RelationalNode\n     * @extends {Node}\n     */\n    constructor(conditionals, params) {\n      super();\n      if (!Array.isArray(conditionals)) {\n        throw new TypeError('Parameter conditionals must be an array');\n      }\n      if (!Array.isArray(params)) {\n        throw new TypeError('Parameter params must be an array');\n      }\n      if (conditionals.length !== params.length - 1) {\n        throw new TypeError('Parameter params must contain exactly one more element ' + 'than parameter conditionals');\n      }\n      this.conditionals = conditionals;\n      this.params = params;\n    }\n    get type() {\n      return name;\n    }\n    get isRelationalNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var self = this;\n      var compiled = this.params.map(p => p._compile(math, argNames));\n      return function evalRelationalNode(scope, args, context) {\n        var evalLhs;\n        var evalRhs = compiled[0](scope, args, context);\n        for (var i = 0; i < self.conditionals.length; i++) {\n          evalLhs = evalRhs;\n          evalRhs = compiled[i + 1](scope, args, context);\n          var condFn = getSafeProperty(math, self.conditionals[i]);\n          if (!condFn(evalLhs, evalRhs)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      this.params.forEach((n, i) => callback(n, 'params[' + i + ']', this), this);\n    }\n\n    /**\n     * Create a new RelationalNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {RelationalNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      return new RelationalNode(this.conditionals.slice(), this.params.map((n, i) => this._ifNode(callback(n, 'params[' + i + ']', this)), this));\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {RelationalNode}\n     */\n    clone() {\n      return new RelationalNode(this.conditionals, this.params);\n    }\n\n    /**\n     * Get string representation.\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n      var paramStrings = this.params.map(function (p, index) {\n        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);\n        return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n      });\n      var ret = paramStrings[0];\n      for (var i = 0; i < this.conditionals.length; i++) {\n        ret += ' ' + operatorMap[this.conditionals[i]];\n        ret += ' ' + paramStrings[i + 1];\n      }\n      return ret;\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        conditionals: this.conditionals,\n        params: this.params\n      };\n    }\n\n    /**\n     * Instantiate a RelationalNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"RelationalNode\", \"conditionals\": ..., \"params\": ...}`,\n     *     where mathjs is optional\n     * @returns {RelationalNode}\n     */\n    static fromJSON(json) {\n      return new RelationalNode(json.conditionals, json.params);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n      var paramStrings = this.params.map(function (p, index) {\n        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);\n        return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n      });\n      var ret = paramStrings[0];\n      for (var i = 0; i < this.conditionals.length; i++) {\n        ret += '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n      }\n      return ret;\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n      var paramStrings = this.params.map(function (p, index) {\n        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);\n        return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n      });\n      var ret = paramStrings[0];\n      for (var i = 0; i < this.conditionals.length; i++) {\n        ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];\n      }\n      return ret;\n    }\n  }\n  _defineProperty(RelationalNode, \"name\", name);\n  return RelationalNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}