{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { map } from '../../utils/array.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { isArray, isConstantNode, isMatrix, isNode, isString, typeOf } from '../../utils/is.js';\nimport { escape } from '../../utils/string.js';\nvar name = 'IndexNode';\nvar dependencies = ['Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node,\n    size\n  } = _ref;\n  class IndexNode extends Node {\n    /**\n     * @constructor IndexNode\n     * @extends Node\n     *\n     * Describes a subset of a matrix or an object property.\n     * Cannot be used on its own, needs to be used within an AccessorNode or\n     * AssignmentNode.\n     *\n     * @param {Node[]} dimensions\n     * @param {boolean} [dotNotation=false]\n     *     Optional property describing whether this index was written using dot\n     *     notation like `a.b`, or using bracket notation like `a[\"b\"]`\n     *     (which is the default). This property is used for string conversion.\n     */\n    constructor(dimensions, dotNotation) {\n      super();\n      this.dimensions = dimensions;\n      this.dotNotation = dotNotation || false;\n\n      // validate input\n      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n      }\n      if (this.dotNotation && !this.isObjectProperty()) {\n        throw new Error('dotNotation only applicable for object properties');\n      }\n    }\n    get type() {\n      return name;\n    }\n    get isIndexNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      // TODO: implement support for bignumber (currently bignumbers are silently\n      //       reduced to numbers when changing the value to zero-based)\n\n      // TODO: Optimization: when the range values are ConstantNodes,\n      //       we can beforehand resolve the zero-based value\n\n      // optimization for a simple object property\n      var evalDimensions = map(this.dimensions, function (dimension, i) {\n        var needsEnd = dimension.filter(node => node.isSymbolNode && node.name === 'end').length > 0;\n        if (needsEnd) {\n          // SymbolNode 'end' is used inside the index,\n          // like in `A[end]` or `A[end - 2]`\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n          var _evalDimension = dimension._compile(math, childArgNames);\n          return function evalDimension(scope, args, context) {\n            if (!isMatrix(context) && !isArray(context) && !isString(context)) {\n              throw new TypeError('Cannot resolve \"end\": ' + 'context must be a Matrix, Array, or string but is ' + typeOf(context));\n            }\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return _evalDimension(scope, childArgs, context);\n          };\n        } else {\n          // SymbolNode `end` not used\n          return dimension._compile(math, argNames);\n        }\n      });\n      var index = getSafeProperty(math, 'index');\n      return function evalIndexNode(scope, args, context) {\n        var dimensions = map(evalDimensions, function (evalDimension) {\n          return evalDimension(scope, args, context);\n        });\n        return index(...dimensions);\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      for (var i = 0; i < this.dimensions.length; i++) {\n        callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n      }\n    }\n\n    /**\n     * Create a new IndexNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {IndexNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      var dimensions = [];\n      for (var i = 0; i < this.dimensions.length; i++) {\n        dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n      }\n      return new IndexNode(dimensions, this.dotNotation);\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {IndexNode}\n     */\n    clone() {\n      return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n    }\n\n    /**\n     * Test whether this IndexNode contains a single property name\n     * @return {boolean}\n     */\n    isObjectProperty() {\n      return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n    }\n\n    /**\n     * Returns the property name if IndexNode contains a property.\n     * If not, returns null.\n     * @return {string | null}\n     */\n    getObjectProperty() {\n      return this.isObjectProperty() ? this.dimensions[0].value : null;\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      // format the parameters like \"[1, 0:5]\"\n      return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        dimensions: this.dimensions,\n        dotNotation: this.dotNotation\n      };\n    }\n\n    /**\n     * Instantiate an IndexNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n     *     where mathjs is optional\n     * @returns {IndexNode}\n     */\n    static fromJSON(json) {\n      return new IndexNode(json.dimensions, json.dotNotation);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      // format the parameters like \"[1, 0:5]\"\n      var dimensions = [];\n      for (var i = 0; i < this.dimensions.length; i++) {\n        dimensions[i] = this.dimensions[i].toHTML();\n      }\n      if (this.dotNotation) {\n        return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n      } else {\n        return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n      }\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var dimensions = this.dimensions.map(function (range) {\n        return range.toTex(options);\n      });\n      return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n    }\n  }\n  _defineProperty(IndexNode, \"name\", name);\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","map","getSafeProperty","factory","isArray","isConstantNode","isMatrix","isNode","isString","typeOf","escape","name","dependencies","createIndexNode","_ref","Node","size","IndexNode","constructor","dimensions","dotNotation","Array","every","TypeError","isObjectProperty","Error","type","isIndexNode","_compile","math","argNames","evalDimensions","dimension","i","needsEnd","filter","node","isSymbolNode","length","childArgNames","Object","create","end","_evalDimension","evalDimension","scope","args","context","s","valueOf","childArgs","index","evalIndexNode","forEach","callback","_ifNode","clone","slice","value","getObjectProperty","_toString","options","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","range","toTex","isClass"],"sources":["/Users/alexgeldash/Projects/calculator/node_modules/mathjs/lib/esm/expression/node/IndexNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { map } from '../../utils/array.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { isArray, isConstantNode, isMatrix, isNode, isString, typeOf } from '../../utils/is.js';\nimport { escape } from '../../utils/string.js';\nvar name = 'IndexNode';\nvar dependencies = ['Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node,\n    size\n  } = _ref;\n  class IndexNode extends Node {\n    /**\n     * @constructor IndexNode\n     * @extends Node\n     *\n     * Describes a subset of a matrix or an object property.\n     * Cannot be used on its own, needs to be used within an AccessorNode or\n     * AssignmentNode.\n     *\n     * @param {Node[]} dimensions\n     * @param {boolean} [dotNotation=false]\n     *     Optional property describing whether this index was written using dot\n     *     notation like `a.b`, or using bracket notation like `a[\"b\"]`\n     *     (which is the default). This property is used for string conversion.\n     */\n    constructor(dimensions, dotNotation) {\n      super();\n      this.dimensions = dimensions;\n      this.dotNotation = dotNotation || false;\n\n      // validate input\n      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n      }\n      if (this.dotNotation && !this.isObjectProperty()) {\n        throw new Error('dotNotation only applicable for object properties');\n      }\n    }\n    get type() {\n      return name;\n    }\n    get isIndexNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      // TODO: implement support for bignumber (currently bignumbers are silently\n      //       reduced to numbers when changing the value to zero-based)\n\n      // TODO: Optimization: when the range values are ConstantNodes,\n      //       we can beforehand resolve the zero-based value\n\n      // optimization for a simple object property\n      var evalDimensions = map(this.dimensions, function (dimension, i) {\n        var needsEnd = dimension.filter(node => node.isSymbolNode && node.name === 'end').length > 0;\n        if (needsEnd) {\n          // SymbolNode 'end' is used inside the index,\n          // like in `A[end]` or `A[end - 2]`\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n          var _evalDimension = dimension._compile(math, childArgNames);\n          return function evalDimension(scope, args, context) {\n            if (!isMatrix(context) && !isArray(context) && !isString(context)) {\n              throw new TypeError('Cannot resolve \"end\": ' + 'context must be a Matrix, Array, or string but is ' + typeOf(context));\n            }\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return _evalDimension(scope, childArgs, context);\n          };\n        } else {\n          // SymbolNode `end` not used\n          return dimension._compile(math, argNames);\n        }\n      });\n      var index = getSafeProperty(math, 'index');\n      return function evalIndexNode(scope, args, context) {\n        var dimensions = map(evalDimensions, function (evalDimension) {\n          return evalDimension(scope, args, context);\n        });\n        return index(...dimensions);\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      for (var i = 0; i < this.dimensions.length; i++) {\n        callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n      }\n    }\n\n    /**\n     * Create a new IndexNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {IndexNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      var dimensions = [];\n      for (var i = 0; i < this.dimensions.length; i++) {\n        dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n      }\n      return new IndexNode(dimensions, this.dotNotation);\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {IndexNode}\n     */\n    clone() {\n      return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n    }\n\n    /**\n     * Test whether this IndexNode contains a single property name\n     * @return {boolean}\n     */\n    isObjectProperty() {\n      return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n    }\n\n    /**\n     * Returns the property name if IndexNode contains a property.\n     * If not, returns null.\n     * @return {string | null}\n     */\n    getObjectProperty() {\n      return this.isObjectProperty() ? this.dimensions[0].value : null;\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      // format the parameters like \"[1, 0:5]\"\n      return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        dimensions: this.dimensions,\n        dotNotation: this.dotNotation\n      };\n    }\n\n    /**\n     * Instantiate an IndexNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n     *     where mathjs is optional\n     * @returns {IndexNode}\n     */\n    static fromJSON(json) {\n      return new IndexNode(json.dimensions, json.dotNotation);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      // format the parameters like \"[1, 0:5]\"\n      var dimensions = [];\n      for (var i = 0; i < this.dimensions.length; i++) {\n        dimensions[i] = this.dimensions[i].toHTML();\n      }\n      if (this.dotNotation) {\n        return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n      } else {\n        return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n      }\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var dimensions = this.dimensions.map(function (range) {\n        return range.toTex(options);\n      });\n      return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n    }\n  }\n  _defineProperty(IndexNode, \"name\", name);\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}