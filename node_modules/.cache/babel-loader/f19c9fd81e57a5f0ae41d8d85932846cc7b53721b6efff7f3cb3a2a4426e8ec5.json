{"ast":null,"code":"import { contains } from './array.js';\nimport { pickShallow } from './object.js';\n\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n  return assertAndCreate;\n}\n\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(factory => {\n    factoriesByName[factory.fn] = factory;\n  });\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n      if (factory.dependencies.some(d => containsDependency(factoriesByName[d], dependency))) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var sorted = [];\n  function addFactory(factory) {\n    var index = 0;\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n    sorted.splice(index, 0, factory);\n  }\n\n  // sort regular factory functions\n  factories.filter(isFactory).forEach(addFactory);\n\n  // sort legacy factory functions AFTER the regular factory functions\n  factories.filter(factory => !isFactory(factory)).forEach(addFactory);\n  return sorted;\n}\n\n// TODO: comment or cleanup if unused in the end\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(factory => factory(scope));\n  return scope;\n}\n\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals\n  .every(dependency => scope[dependency] !== undefined);\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined);\n\n    // TODO: create a custom error class for this, a MathjsError or something like that\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(d => \"\\\"\".concat(d, \"\\\"\")).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}","map":{"version":3,"names":["contains","pickShallow","factory","name","dependencies","create","meta","assertAndCreate","scope","deps","map","stripOptionalNotation","assertDependencies","isFactory","fn","slice","sort","sortFactories","factories","factoriesByName","forEach","containsDependency","dependency","some","d","sorted","addFactory","index","length","splice","filter","arguments","undefined","obj","Array","isArray","allDefined","isOptionalDependency","every","missingDependencies","Error","concat","join"],"sources":["/Users/alexgeldash/Projects/calculator/node_modules/mathjs/lib/esm/utils/factory.js"],"sourcesContent":["import { contains } from './array.js';\nimport { pickShallow } from './object.js';\n\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n  return assertAndCreate;\n}\n\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(factory => {\n    factoriesByName[factory.fn] = factory;\n  });\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n      if (factory.dependencies.some(d => containsDependency(factoriesByName[d], dependency))) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var sorted = [];\n  function addFactory(factory) {\n    var index = 0;\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n    sorted.splice(index, 0, factory);\n  }\n\n  // sort regular factory functions\n  factories.filter(isFactory).forEach(addFactory);\n\n  // sort legacy factory functions AFTER the regular factory functions\n  factories.filter(factory => !isFactory(factory)).forEach(addFactory);\n  return sorted;\n}\n\n// TODO: comment or cleanup if unused in the end\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(factory => factory(scope));\n  return scope;\n}\n\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals\n  .every(dependency => scope[dependency] !== undefined);\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined);\n\n    // TODO: create a custom error class for this, a MathjsError or something like that\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(d => \"\\\"\".concat(d, \"\\\"\")).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,YAAY;AACrC,SAASC,WAAW,QAAQ,aAAa;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,OAAOA,CAACC,IAAI,EAAEC,YAAY,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACxD,SAASC,eAAeA,CAACC,KAAK,EAAE;IAC9B;IACA;IACA;IACA,IAAIC,IAAI,GAAGR,WAAW,CAACO,KAAK,EAAEJ,YAAY,CAACM,GAAG,CAACC,qBAAqB,CAAC,CAAC;IACtEC,kBAAkB,CAACT,IAAI,EAAEC,YAAY,EAAEI,KAAK,CAAC;IAC7C,OAAOH,MAAM,CAACI,IAAI,CAAC;EACrB;EACAF,eAAe,CAACM,SAAS,GAAG,IAAI;EAChCN,eAAe,CAACO,EAAE,GAAGX,IAAI;EACzBI,eAAe,CAACH,YAAY,GAAGA,YAAY,CAACW,KAAK,EAAE,CAACC,IAAI,EAAE;EAC1D,IAAIV,IAAI,EAAE;IACRC,eAAe,CAACD,IAAI,GAAGA,IAAI;EAC7B;EACA,OAAOC,eAAe;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASU,aAAaA,CAACC,SAAS,EAAE;EACvC,IAAIC,eAAe,GAAG,CAAC,CAAC;EACxBD,SAAS,CAACE,OAAO,CAAClB,OAAO,IAAI;IAC3BiB,eAAe,CAACjB,OAAO,CAACY,EAAE,CAAC,GAAGZ,OAAO;EACvC,CAAC,CAAC;EACF,SAASmB,kBAAkBA,CAACnB,OAAO,EAAEoB,UAAU,EAAE;IAC/C;IACA,IAAIT,SAAS,CAACX,OAAO,CAAC,EAAE;MACtB,IAAIF,QAAQ,CAACE,OAAO,CAACE,YAAY,EAAEkB,UAAU,CAACR,EAAE,IAAIQ,UAAU,CAACnB,IAAI,CAAC,EAAE;QACpE,OAAO,IAAI;MACb;MACA,IAAID,OAAO,CAACE,YAAY,CAACmB,IAAI,CAACC,CAAC,IAAIH,kBAAkB,CAACF,eAAe,CAACK,CAAC,CAAC,EAAEF,UAAU,CAAC,CAAC,EAAE;QACtF,OAAO,IAAI;MACb;IACF;IACA,OAAO,KAAK;EACd;EACA,IAAIG,MAAM,GAAG,EAAE;EACf,SAASC,UAAUA,CAACxB,OAAO,EAAE;IAC3B,IAAIyB,KAAK,GAAG,CAAC;IACb,OAAOA,KAAK,GAAGF,MAAM,CAACG,MAAM,IAAI,CAACP,kBAAkB,CAACI,MAAM,CAACE,KAAK,CAAC,EAAEzB,OAAO,CAAC,EAAE;MAC3EyB,KAAK,EAAE;IACT;IACAF,MAAM,CAACI,MAAM,CAACF,KAAK,EAAE,CAAC,EAAEzB,OAAO,CAAC;EAClC;;EAEA;EACAgB,SAAS,CAACY,MAAM,CAACjB,SAAS,CAAC,CAACO,OAAO,CAACM,UAAU,CAAC;;EAE/C;EACAR,SAAS,CAACY,MAAM,CAAC5B,OAAO,IAAI,CAACW,SAAS,CAACX,OAAO,CAAC,CAAC,CAACkB,OAAO,CAACM,UAAU,CAAC;EACpE,OAAOD,MAAM;AACf;;AAEA;AACA,OAAO,SAASpB,MAAMA,CAACa,SAAS,EAAE;EAChC,IAAIV,KAAK,GAAGuB,SAAS,CAACH,MAAM,GAAG,CAAC,IAAIG,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EAClFd,aAAa,CAACC,SAAS,CAAC,CAACE,OAAO,CAAClB,OAAO,IAAIA,OAAO,CAACM,KAAK,CAAC,CAAC;EAC3D,OAAOA,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,SAASA,CAACoB,GAAG,EAAE;EAC7B,OAAO,OAAOA,GAAG,KAAK,UAAU,IAAI,OAAOA,GAAG,CAACnB,EAAE,KAAK,QAAQ,IAAIoB,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC7B,YAAY,CAAC;AACnG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASQ,kBAAkBA,CAACT,IAAI,EAAEC,YAAY,EAAEI,KAAK,EAAE;EAC5D,IAAI4B,UAAU,GAAGhC,YAAY,CAAC0B,MAAM,CAACR,UAAU,IAAI,CAACe,oBAAoB,CAACf,UAAU,CAAC,CAAC,CAAC;EAAA,CACrFgB,KAAK,CAAChB,UAAU,IAAId,KAAK,CAACc,UAAU,CAAC,KAAKU,SAAS,CAAC;EACrD,IAAI,CAACI,UAAU,EAAE;IACf,IAAIG,mBAAmB,GAAGnC,YAAY,CAAC0B,MAAM,CAACR,UAAU,IAAId,KAAK,CAACc,UAAU,CAAC,KAAKU,SAAS,CAAC;;IAE5F;IACA,MAAM,IAAIQ,KAAK,CAAC,2BAA2B,CAACC,MAAM,CAACtC,IAAI,EAAE,MAAM,CAAC,GAAG,iCAAiC,CAACsC,MAAM,CAACF,mBAAmB,CAAC7B,GAAG,CAACc,CAAC,IAAI,IAAI,CAACiB,MAAM,CAACjB,CAAC,EAAE,IAAI,CAAC,CAAC,CAACkB,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;EAClL;AACF;AACA,OAAO,SAASL,oBAAoBA,CAACf,UAAU,EAAE;EAC/C,OAAOA,UAAU,IAAIA,UAAU,CAAC,CAAC,CAAC,KAAK,GAAG;AAC5C;AACA,OAAO,SAASX,qBAAqBA,CAACW,UAAU,EAAE;EAChD,OAAOA,UAAU,IAAIA,UAAU,CAAC,CAAC,CAAC,KAAK,GAAG,GAAGA,UAAU,CAACP,KAAK,CAAC,CAAC,CAAC,GAAGO,UAAU;AAC/E"},"metadata":{},"sourceType":"module","externalDependencies":[]}